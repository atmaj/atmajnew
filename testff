package com.boi.grp.utilities.datafactory;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;

import cucumber.runtime.CucumberException;

public class CompareUtil {
	private File compareFile1;
	private File compareFile2;

	public CompareUtil(String filePath1, String filePath2) {
		compareFile1 = new File(filePath1);
		compareFile2 = new File(filePath2);
	}

	public CompareUtil(File file1, File file2) {
		compareFile1 = file1;
		compareFile2 = file2;
	}

	public void compareCSVs() throws IOException {
		if (FilenameUtils.getExtension(compareFile1.getName()).equalsIgnoreCase(".csv")
				&& FilenameUtils.getExtension(compareFile2.getName()).equalsIgnoreCase(".csv")) {
			String resultFile = compareFile1.getParentFile().getAbsolutePath() + "/csvCompareResult.csv";
			boolean mismatchIdentified = false;
			BufferedWriter writer = new BufferedWriter(new FileWriter(resultFile));

			String fileData = FileUtils.readFileToString(compareFile2, StandardCharsets.UTF_8);
			BufferedReader reader = new BufferedReader(new FileReader(compareFile1));
			writer.write(reader.readLine());
			String line;
			while ((line = reader.readLine()) != null) {
				if (!fileData.contains(line)) {
					writer.write(line);
					mismatchIdentified = true;
				}
			}
			reader.close();
			fileData = FileUtils.readFileToString(compareFile1, StandardCharsets.UTF_8);
			reader = new BufferedReader(new FileReader(compareFile2));
			while ((line = reader.readLine()) != null) {
				if (!fileData.contains(line)) {
					writer.write(line);
					mismatchIdentified = true;
				}
			}
			writer.close();
			if (mismatchIdentified) {
				throw new CucumberException(String.format("Mismatch Found. File : %s", resultFile));
			}
		} else {
			throw new CucumberException(String.format("Both files are not CSV. File 1: %s, File 2: %s",
					compareFile1.getAbsolutePath(), compareFile2.getAbsolutePath()));
		}
	}

	public void compareJSONs() {
		if (compareFile1.getAbsolutePath().toLowerCase().endsWith(".json")
				&& compareFile2.getAbsolutePath().toLowerCase().endsWith(".json")) {

		} else {
			throw new CucumberException(String.format("Both files are not JSON. File 1: %s, File 2: %s",
					compareFile1.getAbsolutePath(), compareFile2.getAbsolutePath()));
		}
	}
}
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;

import java.util.ArrayList;
import java.util.stream.Stream;

public enum DataBaseType {
	MS_SQL_SERVER("com.microsoft.sqlserver.jdbc.SQLServerDriver",
			"jdbc:sqlserver://%s;integratedSecurity=true;databaseName=%s;", "SQL SERVER"),
	MS_SQL_SERVER_NTLM("com.microsoft.sqlserver.jdbc.SQLServerDriver",
			"jdbc:sqlserver://%s;authenticationScheme=NTLM;integratedSecurity=true;domain=boigroup.net;databaseName=%s;",
			"NTML MS-SS", true),
	TERADATA("com.teradata.jdbc.TeraDriver", "jdbc:teradata://%s/LOGMECH=LDAP", "TeraData", true),
	INVALID_DATABASE_TYPE("", "", "");

	private final String driverClass;
	private final String connectionURL;
	private final String dbTypeName;
	private boolean userDetailsRequired = false;

	private DataBaseType(DataBaseType dbType) {
		this.driverClass = dbType.driverClass;
		this.connectionURL = dbType.connectionURL;
		this.dbTypeName = dbType.dbTypeName;
	}

	private DataBaseType(String driverClass, String connectionURL, String dbTypeName) {
		this.driverClass = driverClass.trim();
		this.connectionURL = connectionURL.trim();
		this.dbTypeName = dbTypeName.trim();
	}

	private DataBaseType(String driverClass, String connectionURL, String dbTypeName, boolean userDetailsRequired) {
		this.driverClass = driverClass.trim();
		this.connectionURL = connectionURL.trim();
		this.dbTypeName = dbTypeName.trim();
		this.userDetailsRequired = userDetailsRequired;
	}

	public String getDriverClass() {
		return driverClass;
	}

	public boolean isUserDetailsRequired() {
		return userDetailsRequired;
	}

	public String getConnectionURL() {
		return connectionURL;
	}

	public static DataBaseType getDataBaseType(String dbTypeName) {
		return Stream.of(values()).filter(dbType -> dbType.toString().equalsIgnoreCase(dbTypeName.trim())).findFirst()
				.orElse(null);
		// return Stream.of(values()).filter(dbType ->
		// dbType.toString().equalsIgnoreCase(dbTypeName.trim()))
		// .reduce((first, second) -> first).orElse(null);
	}

	public static ArrayList<String> listAll() {
		ArrayList<String> dbTypeList = new ArrayList<String>();
		Stream.of(values()).forEach(dbType -> dbTypeList.add(dbType.toString()));
		return dbTypeList;
	}

	@Override
	public String toString() {
		return dbTypeName;
	}

}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;

import org.apache.commons.io.FileUtils;

public class DataBaseUtil extends SQLProcessor {
	private boolean sqlExecSkipped = false;
	private String queryExecutionException;

	public DataBaseUtil(String dbHost, String dbName, String dbUserName, String dbPassword) {
		super(dbHost, dbName, dbUserName, dbPassword);
//		scriptQueue.add("BBKG_1");
	}

	public DataBaseUtil(String dbHost, String dbUserName, String dbPassword) {
		super(dbHost, dbUserName, dbPassword);
	}

	public DataBaseUtil(String dbType) {
		super(DataBaseType.getDataBaseType(dbType));
	}

	public DataBaseUtil() {
		super();
	}

	public String getQueryExecutionException() {
		return queryExecutionException;
	}

	public boolean isScriptInQueue(String scriptName) {
		return scriptQueue.contains(scriptName);
	}

	public void initConnection(String... dbConnectionParams) {
		initialize(dbConnectionParams);
	}

	public Object executeQuery(String queryString, Object... queryParams) throws Exception {
		return execute(false, queryString, queryParams);
	}

	public Object executeQuery(String queryString) throws Exception {
		return executeQuery(queryString, new Object[0]);
	}

//	public void initConnection() throws Exception {
//		initDataBaseConnection();
//	}

//	@Override
//	public void finalize() {
//		releaseConnection();
//	}

	public boolean isQueryAlreadyExecuted(String scriptName) {
		scriptName = scriptName.replace(".sql", "");
		boolean queryAlreadyExecuted = false;
		File queryDumpFile = new File(System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR") + "/"
				+ scriptName + "/" + scriptName + ".json");
		if (queryDumpFile.exists()) {
			queryAlreadyExecuted = true;
		}
		return queryAlreadyExecuted;
	}

	public boolean isScriptInFailureList(String scriptName) {
		scriptName = scriptName.replace(".sql", "");
		boolean queryExecutedAndFailed = false;
		File failedScripts = new File(
				System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR") + "/Failed_Query_List");

		if (failedScripts.exists()) {
			try {
				String[] failedScriptDetails = FileUtils.readFileToString(failedScripts, StandardCharsets.UTF_8)
						.split("\n");
				for (String failedScript : failedScriptDetails) {
					String[] failureInfo = failedScript.split("~");
					if (failureInfo[0].trim().equalsIgnoreCase(scriptName)) {
						queryExecutedAndFailed = true;
						queryExecutionException = failureInfo[1].trim();
						break;
					}
				}
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		return queryExecutedAndFailed;
	}

	public void setSQLExecSkipped(boolean isSkipped) {
		sqlExecSkipped = isSkipped;
	}

	public boolean isSQLExecSkipped() {
		return sqlExecSkipped;
	}
}


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;

public class DataTableUtil {

}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;

/**
 * Created by C115190 on 04/30/2020.
 */
import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.json.JSONException;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.csv.CsvMapper;
import com.fasterxml.jackson.dataformat.csv.CsvSchema;
import com.fasterxml.jackson.dataformat.csv.CsvSchema.Builder;

import io.cucumber.datatable.DataTable;

public class ResultSetData {
	private int totalRecordCount = -1;
	private int totalColumnCount;
	private ArrayList<ResultSetRecord> resultSetData = new ArrayList<ResultSetRecord>();
	private ResultSetRecord currentRecord = null;
	private HashMap<String, Integer> metadataMap = new HashMap<String, Integer>();
	private List<String> columnList = new ArrayList<>();
	private List<List<String>> dataTableRaw = new ArrayList<>();
	private ArrayList<ResultSetRecord> filteredResultSet = new ArrayList<ResultSetRecord>();
	private String filterErrors = "";
	// private String timeStamp;
	private File tempJsonFile, filterJsonFile, tempFolder, resultsetDumpFolder, fullDumpCSV, filteredCSV;
//	private boolean resultFiltered;
	// private boolean filteredData;
	private int filteredRecordCount = 0;

	public ResultSetData() throws IOException {
		// timeStamp = new SimpleDateFormat("yyyyMMddhhmmssSSS").format(new
		// java.util.Date());
		tempFolder = new File(System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR.TEMP") + "/");
		resultsetDumpFolder = new File(System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR")
				+ (System.getProperty("QUERY_NAME", "").length() > 0 ? "/" + System.getProperty("QUERY_NAME") + "/"
						: "/"));
		tempFolder.mkdirs();
		resultsetDumpFolder.mkdirs();
		tempJsonFile = System.getProperty("SCRIPT_EXEC", "").equalsIgnoreCase("Y")
				? new File(resultsetDumpFolder + "/" + System.getProperty("QUERY_NAME") + ".json")
				: File.createTempFile("rsData", ".json", tempFolder);
		filterJsonFile = File.createTempFile("rsData", ".json", tempFolder);
		fullDumpCSV = File.createTempFile("rsData_FULL_", ".csv", resultsetDumpFolder);
		filteredCSV = File.createTempFile("rsData_FILTERED_", ".csv", resultsetDumpFolder);
	}

	public int getFilteredRecordCount() {
		return filteredRecordCount;
	}

	public File getTempJsonFile() {
		return tempJsonFile;
	}

	public int getTotalRecordCount() {
		return totalRecordCount;
	}

	public int getTotalColumnCount() {
		return totalColumnCount;
	}

	public ArrayList<ResultSetRecord> getFilteredResultSet() {
		return filteredResultSet;
	}

	public boolean isResultFiltered() {
		return filteredRecordCount > 0;
	}

	public boolean isErrorEncounteredInFilter() {
		return filterErrors.length() != 0;
	}

	public String getFilterErrors() {
		return filterErrors;
	}

	public boolean isEmpty() {
		return totalRecordCount == 0;
	}

	public void pushData(String columnName, Object data, int dataType) {
		if (currentRecord == null) {
			currentRecord = new ResultSetRecord();
		}
		metadataMap.put(columnName, dataType);
		columnList.add(columnName);
		currentRecord.addData(columnName, (data == null ? "" : data));
	}

	public void processRecord() {
		List<String> tableEntry = new ArrayList<String>();
		resultSetData.add(currentRecord);
		totalRecordCount++;
		totalColumnCount = metadataMap.size();
		for (String column : columnList) {
			tableEntry.add(String.valueOf(currentRecord.getData(column)));
		}
		dataTableRaw.add(tableEntry);
		currentRecord = null;
	}

	public ResultSetRecord getRecord(int recordIndex) {
		return resultSetData.get(recordIndex);
	}

	public List<Object> getData(String columnName) {
		ArrayList<Object> columnData = new ArrayList<Object>();
		for (ResultSetRecord record : resultSetData) {
			columnData.add(record.getData(columnName));
		}
		return Collections.unmodifiableList(columnData);
	}

	public Object getData(int recordIndex, String columnName) {
		return resultSetData.get(recordIndex).getData(columnName);
	}

	public Object getData(int recordIndex, int columnIndex) {
		String columnName = String.valueOf(metadataMap.keySet().toArray()[columnIndex]);
		return getData(recordIndex, columnName);
	}

	public DataTable getDataTable() {
		dataTableRaw.add(0, columnList);
		return DataTable.create(dataTableRaw);
	}

	public void filterRecords(String filterData) {
		filterRecords(null, filterData);
	}

	public void filterRecords(String sourceFileName, String columns, String filterData) {
		resultsetDumpFolder = new File(System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR") + "/"
				+ sourceFileName + "/");
//			tempJsonFile.delete();
		tempJsonFile = new File(resultsetDumpFolder + "/" + sourceFileName + ".json");
		totalRecordCount = ResultSetJsonUtil.isRecordsAvailableInJson(tempJsonFile) ? 1 : 0;
		columnList = ResultSetJsonUtil.getColumnList(tempJsonFile);

		fullDumpCSV.delete();
		filteredCSV.delete();
		try {
//			fullDumpCSV = File.createTempFile("rsData_FULL_", ".csv", resultsetDumpFolder);
			filteredCSV = File.createTempFile("rsData_FILTERED_", ".csv", resultsetDumpFolder);
		} catch (IOException e) {
			e.printStackTrace();
		}

		filterRecords(columns, filterData);
	}

	public void filterRecords(String filterColumn, String filterData) {
		if (totalRecordCount > 0) {
//			if (columnList.stream().map(columnName -> columnName.trim()).anyMatch(filterColumn::equalsIgnoreCase)) {
			if (columnList.contains(filterColumn)) {
				filteredRecordCount = ResultSetJsonUtil.filterJson(tempJsonFile, filteredCSV, 5, filterColumn,
						filterData);
			} else {
				filterErrors = filterColumn + " is not available in the resultset. Check your test data\n";
				String potentialColumn = columnList.stream()
						.filter(columnName -> columnName.equalsIgnoreCase(filterColumn)).findAny().orElse("");
				if (!potentialColumn.isEmpty())
					filterErrors += "Potential Column: " + potentialColumn;
			}
		} else {
			filterErrors = "Query didn't return any resultset. Check the script";
		}
	}

	public String getFilteredCSV() {
		return filteredCSV.getPath();
	}

	public String generateCSV() {
		return generateCSV(false);
	}

	public String generateCSV(boolean filteredSetOnly) {
		File targetFile = filteredSetOnly ? filterJsonFile : tempJsonFile;
		File resultFile = filteredSetOnly ? filteredCSV : fullDumpCSV;
		try {
			JsonNode jsonTree = new ObjectMapper().readTree(targetFile);
			Builder csvBuilder = CsvSchema.builder();
			JsonNode first = jsonTree.elements().next();
			first.fieldNames().forEachRemaining(fieldName -> {
				csvBuilder.addColumn(fieldName);
			});
			CsvSchema csvSchema = csvBuilder.build().withHeader();

			CsvMapper csvMapper = new CsvMapper();
			csvMapper.writerFor(JsonNode.class).with(csvSchema).writeValue(resultFile, jsonTree);
			return (resultFile.getPath());
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	public class ResultSetRecord {
		private HashMap<String, Object> recordData = new HashMap<String, Object>();

		public int getRecordSize() {
			return recordData.size();
		}

		public boolean isDataAvailable(String columnName) {
			return recordData.containsKey(columnName);
		}

		public Object getData(String columnName) {
			return recordData.getOrDefault(columnName, null);
		}

		private void addData(String columnName, Object data) {
			recordData.put(columnName, data);
		}
	}

	public void upddateMetaData(ResultSet result) throws JSONException, SQLException, IOException {
		result.last();
		totalRecordCount = result.getRow();
		result.beforeFirst();

		ResultSetMetaData rsMetadata = result.getMetaData();
		totalColumnCount = rsMetadata.getColumnCount();
		for (int counter = 1; counter <= totalColumnCount; counter++) {
			String columnName = rsMetadata.getColumnName(counter);
			int columnType = rsMetadata.getColumnType(counter);
			columnList.add(columnName);
			metadataMap.put(columnName, columnType);
		}

		if (totalRecordCount <= 0) {
			FileUtils.write(
					new File(System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR")
							+ "/Failed_Query_List"),
					System.getProperty("QUERY_NAME", "") + "~Query didn't return any resultset\n",
					StandardCharsets.UTF_8, true);
		}
	}

	public void clearTempFiles() {
//		if (!System.getProperty("SCRIPT_EXEC", "").equalsIgnoreCase("Y")) {
////			tempJsonFile.delete();
//		}
//		filterJsonFile.delete();
	}
}


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;
import com.google.gson.internal.Streams;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.Option;
import com.jayway.jsonpath.ParseContext;
import com.jayway.jsonpath.spi.json.GsonJsonProvider;

public class ResultSetJsonUtil {
	public static String pathEvaluator(File json, String path) {
		Configuration conf = Configuration.builder().jsonProvider(new GsonJsonProvider())
				.options(Option.ALWAYS_RETURN_LIST, Option.SUPPRESS_EXCEPTIONS).build();
		ParseContext parseContext = JsonPath.using(conf);
		try {
			return ((JsonArray) parseContext.parse(json).read(path)).get(0).toString();
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	public static String fetchJsonSubString(String sourceJson, List<String> keyList, int retainSequenceCap,
			String[] additionalColumns) {
		String modifiedString = "";

		JsonArray json = JsonParser.parseString(sourceJson).getAsJsonArray();
		JsonArray json1 = new JsonArray();
		json.forEach(jsonEl -> {
			JsonObject newJsonEl = new JsonObject();
			JsonObject currentJsonElement = jsonEl.getAsJsonObject();
			for (int counter = 0; counter < retainSequenceCap; counter++) {
				String key = keyList.get(counter);
				newJsonEl.add(key, currentJsonElement.get(key));
			}
			for (int counter = 0; counter < additionalColumns.length; counter++) {
				String key = additionalColumns[counter];
				newJsonEl.add(key, currentJsonElement.get(key));
			}
			json1.add(newJsonEl);
		});
		modifiedString = json1.toString();
		return modifiedString;
	}

	public static int filterJson(File tempJsonFile, File filteredCSV, int retainColumnCount, String filterColumn,
			String filterData) {
		int filteredRecordCounter = 0;
		try (JsonReader reader = new JsonReader(new FileReader(tempJsonFile));
				FileWriter writer = new FileWriter(filteredCSV)) {
			reader.beginArray();
			boolean recordEntered = false;
			while (reader.hasNext()) {
				StringBuffer csvHeader = new StringBuffer();
				StringBuffer csvRecord = new StringBuffer();
				int counter = 0;
				reader.beginObject();
				while (reader.hasNext()) {
					String key = getFieldValue(reader).trim();
					String value = getFieldValue(reader).trim();

					if (counter < retainColumnCount) {
						csvHeader.append(key).append(",");
						csvRecord.append(value).append(",");
					} else if (key.equals(filterColumn)) {
						if (value.equalsIgnoreCase(filterData)) {
							csvHeader.append(key).append(",");
							csvRecord.append(value).append(",");
							if (csvRecord.length() > 0) {
								if (!recordEntered) {
									writer.write(csvHeader.toString());
									writer.write(System.lineSeparator());
									recordEntered = true;
								}
								writer.write(csvRecord.toString());
								writer.write(System.lineSeparator());
								filteredRecordCounter++;
							}
						}
						csvHeader = new StringBuffer();
						csvRecord = new StringBuffer();
						break;
					}
					counter++;
				}
				while (!reader.peek().equals(JsonToken.END_OBJECT)) {
					reader.skipValue();
				}
				reader.endObject();
			}
			reader.endArray();
			writer.flush();
		} catch (IOException e) {
			e.printStackTrace();
		}

		return filteredRecordCounter;
	}

	private static String getFieldValue(JsonReader reader) throws IOException {
		while (reader.hasNext()) {
			JsonToken check = reader.peek();
			switch (check) {
			case NULL:
				reader.nextNull();
				return "";
			case NAME:
				return reader.nextName();
			case BOOLEAN:
				return String.valueOf(reader.nextBoolean());
			case NUMBER:
			case STRING:
				return reader.nextString();
			default:
				break;
			}
		}
		return null;
	}

	public static int getRecordCount(File jsonArrayFile) {
		int recordCount = 0;
		try (JsonReader reader = new JsonReader(new FileReader(jsonArrayFile))) {
			reader.beginArray();
			while (reader.hasNext()) {
				if (reader.peek().equals(JsonToken.BEGIN_OBJECT))
					recordCount++;
				reader.skipValue();
			}
			reader.endArray();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return recordCount;
	}

	public static List<String> getColumnList(File jsonArrayFile) {
		List<String> columnList = new ArrayList<String>();
		try (JsonReader reader = new JsonReader(new FileReader(jsonArrayFile))) {
			reader.beginArray();
			while (reader.hasNext()) {
				if (reader.peek().equals(JsonToken.NAME))
					columnList.add(reader.nextName());
				else if (reader.peek().equals(JsonToken.END_OBJECT))
					break;
				else if (reader.peek().equals(JsonToken.BEGIN_OBJECT))
					reader.beginObject();
				else
					reader.skipValue();
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return columnList;
	}

	public static boolean isRecordsAvailableInJson(File jsonFile) {
		boolean recordExists = true;
		if (jsonFile.length() < 20) {
			try {
				int recordSize = Streams.parse(new JsonReader(new FileReader(jsonFile))).getAsJsonArray().size();
				if (recordSize == 0) {
					recordExists = false;
				}
			} catch (JsonParseException | FileNotFoundException e) {
				e.printStackTrace();
			}
		}
		return recordExists;
	}
}


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
/**
 * Created by C115190 on 04/30/2020.
 */
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import org.apache.commons.io.FileUtils;
import org.httprpc.io.JSONEncoder;
import org.httprpc.sql.ResultSetAdapter;

import com.boi.grp.Crypter;
import com.boi.grp.pageobjects.BasePage;

public class SQLProcessor extends BasePage {
	private CRUD currentOperation = CRUD.READ;
	private String connectionUrl;
	private boolean connectionInitiated = false;
//	private Connection connection;
	private DataBaseType dataBaseType;
	private String dbHost;
	private String dbUser;
	private String dbPassword;
	private String dbName;
	private Object outcome;
	private boolean exceptionEncountered = false;
	private Throwable encounteredException = null;
	private int retryThreshold = 0;
	private int recoveryThreshold;
	private int retryCounter = 0;
//	private boolean scriptFileInExecution;

	public static List<String> scriptQueue = new ArrayList<>();

	public SQLProcessor() {
		dbUser = System.getProperty("DB.USERNAME");
		dbPassword = System.getProperty("DB.PASSWORD");
		dataBaseType = DataBaseType.INVALID_DATABASE_TYPE;
	}

	public SQLProcessor(DataBaseType dbType) {
		dbUser = System.getProperty("DB.USERNAME");
		dbPassword = System.getProperty("DB.PASSWORD");
		dataBaseType = dbType;
	}

	public SQLProcessor(String... dbConnectionParams) {
		initialize(dbConnectionParams);
	}

	public boolean isConnectionInitiated() {
		return this.connectionInitiated;
	}

//	public void setScriptFileInExecution(boolean scriptFileInExecution) {
//		this.scriptFileInExecution = scriptFileInExecution;
//	}

	public boolean isExceptionEncountered() {
		return exceptionEncountered;
	}

	public Throwable getEncounteredException() {
		return encounteredException;
	}

	public void setDataBaseType(String dbTypeName) {
		dataBaseType = DataBaseType.getDataBaseType(dbTypeName);
	}

	public void setDataBase(String dbName) {
		this.dbName = dbName;
	}

	private void setConnectionUrl(String connectionUrl) {
		this.connectionUrl = connectionUrl;
	}

	public void setCurrentOperation(CRUD currentOperation) {
		this.currentOperation = currentOperation;
	}

	protected void initialize(String... dbConnectionParams) {
		init(dbConnectionParams);
	}

	public void init() {
		init(dbHost, dbName);
	}

	private void init(String... connectionParams) {
		retryThreshold = Integer.parseInt(System.getProperty("DB.CONNECTION.RETRY.THRESHOLD", "0"));
		recoveryThreshold = Integer.parseInt(System.getProperty("DB.CONNECTION.RECOVERYTIME.THRESHOLD", "0"));
		dbHost = connectionParams[0];
		dataBaseType = dataBaseType.equals(DataBaseType.INVALID_DATABASE_TYPE)
				? DataBaseType.getDataBaseType(System.getProperty("DB.TYPE"))
				: dataBaseType;
		try {
			String driverClass = dataBaseType.getDriverClass();
			Class.forName(driverClass);
			switch (dataBaseType) {
			case MS_SQL_SERVER:
				setConnectionUrl(String.format(dataBaseType.getConnectionURL(), dbHost, dbName, "", ""));
				break;
			case TERADATA:
				setConnectionUrl(String.format(dataBaseType.getConnectionURL(), dbHost));
				break;
			default:
				throw new SQLException(dataBaseType.toString() + " has not been implemented yet");
			}
//			if (dbName != null) {
//				initDataBaseConnection();
//			}
		} catch (Exception e) {
			exceptionEncountered = true;
			encounteredException = e;
			e.printStackTrace();
			logMan.error("Failed to capture connection properties", e);
			return;
		}
		this.connectionInitiated = true;
		logMan.info("Connection properties captured for " + dataBaseType.toString());
	}

	protected Object execute(boolean isStoredProc, String queryString, Object[] queryParams) throws Exception {
		if (!isConnectionInitiated()) {
			init();
		}

		String queryToBeExecuted = queryString;
		if (isStoredProc) {
			queryToBeExecuted = String
					.format("Call %s(%s)", queryString, String.join("", Collections.nCopies(queryParams.length, "?, ")))
					.trim();
			queryToBeExecuted = queryParams.length > 0 ? queryToBeExecuted.substring(0, queryToBeExecuted.length())
					: queryToBeExecuted;
		}
		return isStoredProc ? executeStoredProcedure(queryString, queryParams) : executeQuery(queryString, queryParams);
	}

	private Object executeStoredProcedure(String storedProcName, Object... queryParams) throws Exception {
		Object outcome = null;
		try (Connection connection = getConnection()) {
			String queryString = String.format("Call %s(%s)", storedProcName,
					String.join("", Collections.nCopies(queryParams.length, "?, "))).trim();
			queryString = queryParams.length > 0 ? queryString.substring(0, queryString.length()) : queryString;

			executeQuery(connection, CallableStatement.class, queryString, queryParams);
		} catch (SQLException e) {
			throw e;
		}
		return outcome;
	}

	private Object executeQuery(String queryString, Object... queryParams) throws Exception {
		try (Connection connection = getConnection()) {
			executeQuery(connection, PreparedStatement.class, queryString, queryParams);
		} catch (Exception e) {
			throw e;
		}
		return outcome;
	}

	protected Object executeQuery_Thread(String queryString, Object... queryParams) {
		Thread thread = new Thread() {
			@Override
			public void run() {
				try (Connection connection = getConnection()) {
					executeQuery(connection, PreparedStatement.class, queryString, queryParams);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		};
		thread.start();
		try {
			thread.join();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		return outcome;
	}

	private Connection getConnection() throws Exception {
		logMessage("Connection Setup");
		Connection connection;
		while (true) {
			try {
				if (dataBaseType.isUserDetailsRequired()) {
					dbUser = Crypter.decrypt(dbUser);
					dbPassword = Crypter.decrypt(dbPassword);
					connection = DriverManager.getConnection(connectionUrl, dbUser, dbPassword);
				} else
					connection = DriverManager.getConnection(connectionUrl);
				break;
			} catch (Exception e) {
				if (retryCounter >= retryThreshold) {
					exceptionEncountered = true;
					encounteredException = e;
					e.printStackTrace();
					logMan.error("Execution failed", e);
					throw e;
				} else {
					retryCounter++;
					logMan.warn("Connection failed. Giving the system " + recoveryThreshold + " seconds to recover...");
					Thread.sleep(recoveryThreshold * 1000);
					logMan.warn("Re-executing the query. Attempt #" + retryCounter);
				}
			}
		}
		retryCounter = 0;

		logMessage("Connection Established");
		return connection;
	}

	private <T extends PreparedStatement> void executeQuery(Connection connection, Class<T> statementClass,
			String queryString, Object[] queryParams) throws Exception {
		try (T statement = getStatement(connection, statementClass, queryString, queryParams)) {
			switch (currentOperation) {
			case READ:
				long startTime = System.currentTimeMillis();
				try (ResultSet resultSet = statement.executeQuery()) {
					long endTime = System.currentTimeMillis();
					long execuDuration = endTime - startTime;
					logMan.info(String.format("Query Execution Time: %.2f seconds", (float) execuDuration / 1000));
					outcome = transformResultSet(resultSet);
				}
				break;
			default:
				outcome = statement.executeUpdate();
			}
		} catch (Exception e) {
			exceptionEncountered = true;
			encounteredException = e;
			e.printStackTrace();
			logMan.error("SQL Script Execution failed - " + System.getProperty("QUERY_NAME", ""), e);
			FileUtils.write(
					new File(System.getProperty("user.dir") + "/" + System.getProperty("RESULTSET.DIR")
							+ "/Failed_Query_List"),
					System.getProperty("QUERY_NAME", "") + "~" + e.getLocalizedMessage() + "\n", StandardCharsets.UTF_8,
					true);
			throw e;
		}
	}

	@SuppressWarnings("unchecked")
	private <T extends PreparedStatement> T getStatement(Connection connection, Class<T> statementClass,
			String queryString, Object[] queryParams) throws SQLException {
		T statement = null;
		String statementClassName = statementClass.getSimpleName();

		if (statementClassName.equals("CallableStatement"))
			statement = (T) connection.prepareCall(queryString, ResultSet.TYPE_SCROLL_SENSITIVE,
					ResultSet.CONCUR_READ_ONLY);
		else if (statementClassName.equals("PreparedStatement"))
			statement = (T) connection.prepareStatement(queryString, ResultSet.TYPE_SCROLL_SENSITIVE,
					ResultSet.CONCUR_READ_ONLY);
		statement.setFetchSize(50);
		if (queryParams != null && queryParams.length > 0) {
			return setQueryParam(statement, queryParams);
		}
		return statement;
	}

	public <T extends PreparedStatement> T setQueryParam(T statement, Object... queryParams) throws SQLException {
		int queryParamIndex = 0;
		for (Object queryParam : queryParams) {
			String paramType = queryParam.getClass().getSimpleName();
			switch (paramType) {
			case "Integer":
				statement.setInt(++queryParamIndex, (int) queryParam);
				break;
			case "BigDecimal":
				statement.setBigDecimal(++queryParamIndex, (BigDecimal) queryParam);
				break;
			case "Float":
				statement.setFloat(++queryParamIndex, (float) queryParam);
				break;
			case "Double":
				statement.setDouble(++queryParamIndex, (double) queryParam);
				break;
			case "Long":
				statement.setLong(++queryParamIndex, (long) queryParam);
				break;
			case "Boolean":
				statement.setBoolean(++queryParamIndex, (boolean) queryParam);
				break;
			case "Date":
				statement.setDate(++queryParamIndex, (Date) queryParam);
				break;
			case "String":
				statement.setString(++queryParamIndex, String.valueOf(queryParam));
				break;
			default:
				throw new SQLException(paramType + " query parameter has not been implemented yet");
			}
		}
		return statement;
	}

	ResultSetData transformResultSetToCollection_NotToUse(ResultSet result) throws SQLException {
		try {
			ResultSetData resultSetData = new ResultSetData();
			if (result.isBeforeFirst()) {
				ResultSetMetaData rsMetaData = result.getMetaData();
				while (result.next()) {
					for (int counter = 1; counter <= rsMetaData.getColumnCount(); counter++) {
						String columnName = rsMetaData.getColumnName(counter);
						int columnDataType = rsMetaData.getColumnType(counter);
						switch (columnDataType) {
						case Types.VARCHAR:
						case Types.NVARCHAR:
						case Types.LONGVARCHAR:
						case Types.LONGNVARCHAR:
							resultSetData.pushData(columnName, result.getString(columnName), columnDataType);
							break;
						case Types.INTEGER:
						case Types.NUMERIC:
							resultSetData.pushData(columnName, result.getInt(columnName), columnDataType);
							break;
						case Types.DOUBLE:
						case Types.DECIMAL:
							resultSetData.pushData(columnName, result.getDouble(columnName), columnDataType);
							break;
						case Types.FLOAT:
							resultSetData.pushData(columnName, result.getFloat(columnName), columnDataType);
							break;
						case Types.DATE:
							resultSetData.pushData(columnName, result.getDate(columnName), columnDataType);
							break;
						case Types.BOOLEAN:
							resultSetData.pushData(columnName, result.getBoolean(columnName), columnDataType);
							break;
						default:
							throw new SQLException(
									rsMetaData.getColumnTypeName(counter) + " has not been implemented yet");
						}
					}
					resultSetData.processRecord();
				}
			}
			return resultSetData;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	private ResultSetData transformResultSet(ResultSet result) throws SQLException {
		try {
			ResultSetData resultSetData = new ResultSetData();
			resultSetData.upddateMetaData(result);
			try (ResultSetAdapter resultSetAdapter = new ResultSetAdapter(result)) {
				JSONEncoder jsonEncoder = new JSONEncoder();
				FileOutputStream fos = new FileOutputStream(resultSetData.getTempJsonFile());
				jsonEncoder.write(resultSetAdapter, fos);
				fos.close();
				if (System.getProperty("DB.ATTACH.QUERYRESULT").equals("TRUE")) {
					resultSetData.generateCSV();
				}
			}
			return resultSetData;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

//	protected void releaseConnection() {
//		try {
//			if (connection != null || !connection.isClosed()) {
//				connection.close();
//			}
//		} catch (SQLException e) {
//			e.printStackTrace();
//		}
//		connection = null;
//	}

	protected enum CRUD {
		CREATE, READ, UPDATE, DELETE;
	}
}


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.datafactory;
//*********************************************************************

//
//                 Copyright (c) 2016 by Teradata Corporation
//                         All Rights Reserved
//
//*********************************************************************
//
//  File:       TJEncryptPassword.java
//  Purpose:    Encrypts a password, saves the encryption key in one file, and saves the encrypted password in a second file
//
//              This program accepts eight command-line arguments:
//
//                1. Transformation - transformation argument for the Cipher.getInstance method.
//                                    Example: AES/CBC/NoPadding
//
//                2. KeySizeInBits  - keysize argument for the KeyGenerator.init method.
//                                    Specify -default to use the transformation's default key size.
//                                    Example: -default
//
//                                    To use AES with a 192-bit or 256-bit key, the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files
//                                    must be downloaded from Oracle and installed in your JRE.
//                                    Example: 256
//
//                3. MAC            - algorithm argument for the Mac.getInstance method.
//                                    MAC algorithm HmacSHA256 is available with JDK 5 and later. MAC algorithm HmacSHA1 is available with JDK 1.4.2.
//                                    Example: HmacSHA256
//
//                4. PasswordEncryptionKeyFileName - a filename in the current directory, a relative pathname, or an absolute pathname.
//                                    The file is created by this program. If the file already exists, it will be overwritten by the new file.
//                                    Example: PassKey.properties
//
//                5. EncryptedPasswordFileName - a filename in the current directory, a relative pathname, or an absolute pathname.
//                                    The filename or pathname that must differ from the PasswordEncryptionKeyFileName.
//                                    The file is created by this program. If the file already exists, it will be overwritten by the new file.
//                                    Example: EncPass.properties
//
//                6. Hostname       - the Teradata Database hostname.
//                                    Example: whomooz
//
//                7. Username       - the Teradata Database username.
//                                    Example: guest
//
//                8. Password       - the Teradata Database password to be encrypted.
//                                    Unicode characters in the password can be specified with the backslash uXXXX escape sequence.
//                                    Example: please
//
//              Overview
//              --------
//
//              Teradata JDBC Driver Stored Password Protection enables an application to provide a JDBC connection password in encrypted form to
//              the Teradata JDBC Driver, and also enables an application to provide the NEW_PASSWORD connection parameter's value in encrypted form.
//
//              Stored Password Protection is available beginning with Teradata JDBC Driver 16.00.00.24.
//
//              There are several different ways that an application may specify a password to the Teradata JDBC Driver, all of which may use an
//              encrypted password:
//                1. A login password specified as the third argument to the DriverManager.getConnection(String,String,String) method.
//                2. A login password specified as the "password" property to the DriverManager.getConnection(String,Properties) method.
//                3. A login password specified as the PASSWORD connection URL parameter with the DriverManager.getConnection(String) method.
//                4. A login password specified within the LOGDATA connection URL parameter with any variant of the DriverManager.getConnection method.
//                5. A login password specified as the DataSource or ConnectionPoolDataSource password parameter.
//                6. A login password specified within the DataSource or ConnectionPoolDataSource LOGDATA parameter.
//                7. A new password specified as the NEW_PASSWORD connection URL parameter with any variant of the DriverManager.getConnection method.
//                8. A new password specified as the DataSource or ConnectionPoolDataSource NEW_PASSWORD parameter.
//
//              If the password, however specified, begins with the prefix "ENCRYPTED_PASSWORD(" then the specified password must follow this format:
//
//                ENCRYPTED_PASSWORD(PasswordEncryptionKeyResourceName,EncryptedPasswordResourceName)
//
//              The PasswordEncryptionKeyResourceName must be separated from the EncryptedPasswordResourceName by a single comma.
//              The PasswordEncryptionKeyResourceName specifies the name of a resource that contains the password encryption key and associated information.
//              The EncryptedPasswordResourceName specifies the name of a resource that contains the encrypted password and associated information.
//              The two resources are described below.
//
//              When an encrypted password is specified for the PASSWORD, NEW_PASSWORD, and/or LOGDATA connection URL parameters, the value must be
//              enclosed in single quotes, to enclose the "ENCRYPTED_PASSWORD(" syntax's comma separator for the resource names, otherwise that comma
//              would be interpreted as a separator for the next connection URL parameter.
//
//              This program works in conjunction with Teradata JDBC Driver Stored Password Protection.
//              This program creates the files containing the password encryption key and encrypted password, which can be subsequently specified to
//              the Teradata JDBC Driver via the "ENCRYPTED_PASSWORD(" syntax.
//
//              You are not required to use this program to create the files containing the password encryption key and encrypted password.
//              You can develop your own software to create the necessary files.
//              The only requirement is that the files must match the format expected by the Teradata JDBC Driver, which is documented below.
//
//              This program encrypts the password and then immediately decrypts the password, in order to verify that the password can be
//              successfully decrypted. This program mimics the implementation of the Teradata JDBC Driver's password decryption, and is
//              intended to openly illustrate its operation and enable scrutiny by the community.
//
//              The encrypted password is only as safe as the two files. You are responsible for restricting access to the files containing the
//              password encryption key and encrypted password. If an attacker obtains both files, the password can be decrypted.
//              The operating system file permissions for the two files should be as limited and restrictive as possible, to ensure that only the
//              intended operating system userid has access to the files.
//
//              The two files can be kept on separate physical volumes, to reduce the risk that both files might be lost at the same time.
//              If either or both of the files are located on a network volume, then an encrypted wire protocol can be used to access the
//              network volume, such as sshfs, encrypted NFSv4, or encrypted SMB 3.0.
//
//              Password Encryption Key File Format
//              -----------------------------------
//
//              The password encryption key file is a text file in Java Properties file format, using the ISO 8859-1 character encoding.
//              The file must contain the following string properties:
//
//                version=1
//
//                      The version number must be 1.
//                      This property is required.
//
//                transformation=TransformationName
//
//                      This value must be a valid transformation argument for the Cipher.getInstance method.
//                      This property is required.
//
//                algorithm=AlgorithmName
//
//                      This value must correspond to the algorithm portion of the transformation.
//                      This value must be a valid algorithm argument for the KeyGenerator.getInstance method.
//                      This property is required.
//
//                match=MatchValue
//
//                      The password encryption key and encrypted password files must contain the same match value.
//                      The match values are compared to ensure that the two specified files are related to each other,
//                      serving as a "sanity check" to help avoid configuration errors.
//                      This property is required.
//
//                      This program uses a timestamp as a shared match value, but a timestamp is not required.
//                      Any shared string can serve as a match value. The timestamp is not related in any way to the encryption of the
//                      password, and the timestamp cannot be used to decrypt the password.
//
//                key=HexDigits
//
//                      This value is the password encryption key, encoded as hex digits.
//                      This property is required.
//
//                mac=AlgorithmName
//
//                      This value must be a valid algorithm argument for the Mac.getInstance method.
//                      Teradata JDBC Driver Stored Password Protection performs Encrypt-then-MAC for protection from a padding oracle attack.
//                      This property is required.
//
//                mackey=HexDigits
//
//                      This value is the MAC key, encoded as hex digits.
//                      This property is required.
//
//              Encrypted Password File Format
//              ------------------------------
//
//              The encrypted password file is a text file in Java Properties file format, using the ISO 8859-1 character encoding.
//              The file must contain the following string properties:
//
//                version=1
//
//                      The version number must be 1.
//                      This property is required.
//
//                match=MatchValue
//
//                      The password encryption key and encrypted password files must contain the same match value.
//                      The match values are compared to ensure that the two specified files are related to each other,
//                      serving as a "sanity check" to help avoid configuration errors.
//                      This property is required.
//
//                      This program uses a timestamp as a shared match value, but a timestamp is not required.
//                      Any shared string can serve as a match value. The timestamp is not related in any way to the encryption of the
//                      password, and the timestamp cannot be used to decrypt the password.
//
//                password=HexDigits
//
//                      This value is the encrypted password, encoded as hex digits.
//                      This property is required.
//
//                params=HexDigits
//
//                      This value contains the cipher algorithm parameters, if any, encoded as hex digits.
//                      Some ciphers need algorithm parameters that cannot be derived from the key, such as an initialization vector.
//                      This property is optional, depending on whether the cipher algorithm has associated parameters.
//
//                hash=HexDigits
//
//                      This value is the expected message authentication code (MAC), encoded as hex digits.
//                      After encryption, the expected MAC is calculated using the ciphertext, transformation name, and algorithm parameters if any.
//                      Before decryption, the Teradata JDBC Driver calculates the MAC using the ciphertext, transformation name, and algorithm
//                      parameters if any, and verifies that the calculated MAC matches the expected MAC.
//                      If the calculated MAC differs from the expected MAC, then either or both of the files may have been tampered with.
//                      This property is required.
//
//              Transformation, Key Size, and MAC
//              ---------------------------------
//
//              A transformation is a string that describes the set of operations to be performed on the given input, to produce transformed output.
//              A transformation always includes the name of a cryptographic algorithm such as DES or AES, and may optionally be followed by a feedback mode
//              and padding scheme.
//
//              The JDK 7 javadoc for javax.crypto.Cipher indicates that every Java implementation must support the following transformations:
//
//                AES/CBC/NoPadding
//                AES/CBC/PKCS5Padding
//                AES/ECB/NoPadding
//                AES/ECB/PKCS5Padding
//                DES/CBC/NoPadding
//                DES/CBC/PKCS5Padding
//                DES/ECB/NoPadding
//                DES/ECB/PKCS5Padding
//                DESede/CBC/NoPadding
//                DESede/CBC/PKCS5Padding
//                DESede/ECB/NoPadding
//                DESede/ECB/PKCS5Padding
//                RSA/ECB/PKCS1Padding
//                RSA/ECB/OAEPWithSHA-1AndMGF1Padding
//                RSA/ECB/OAEPWithSHA-256AndMGF1Padding
//
//              Teradata JDBC Driver Stored Password Protection uses a symmetric encryption algorithm such as DES or AES, in which the same secret key is used
//              for encryption and decryption of the password.
//              Teradata JDBC Driver Stored Password Protection does not use an asymmetric encryption algorithm such as RSA, with separate public and public keys.
//
//              ECB (Electronic Codebook) is the simplest block cipher encryption mode. The input is divided into blocks, and each block is encrypted separately.
//              ECB is unsuitable for encrypting data whose total byte count exceeds the algorithm's block size, and is therefore unsuitable for use with
//              Teradata JDBC Driver Stored Password Protection.
//              CBC (Cipher Block Chaining) is a more complex block cipher encryption mode. With CBC, each ciphertext block is dependent on all plaintext blocks
//              processed up to that point. CBC is suitable for encrypting data whose total byte count exceeds the algorithm's block size, and is therefore
//              suitable for use with Teradata JDBC Driver Stored Password Protection.
//
//              Teradata JDBC Driver Stored Password Protection hides the password length in the encrypted password file by extending the length of the
//              UTF8-encoded password with trailing null bytes. The length is extended to the next 512-byte boundary.
//              A block cipher with no padding, such as AES/CBC/NoPadding, may only be used to encrypt data whose byte count after extension is a multiple
//              of the algorithm's block size.
//              The 512-byte boundary is compatible with many block ciphers. AES, for example, has a block size of 128 bits (16 bytes), and is therefore
//              compatible with the 512-byte boundary.
//
//              A block cipher with padding, such as AES/CBC/PKCS5Padding, can be used to encrypt data of any length.
//              However, CBC with padding is vulnerable to a "padding oracle attack", so Teradata JDBC Driver Stored Password Protection performs Encrypt-then-MAC
//              for protection from a padding oracle attack.
//              MAC algorithm HmacSHA256 is available with JDK 5 and later. MAC algorithm HmacSHA1 is available with JDK 1.4.2.
//
//              A block cipher can encrypt data in units smaller than the cipher's actual block size when using a mode such as CFB (Cipher Feedback)
//              or OFB (Output Feedback).
//              A block cipher can be used as a byte-oriented cipher by specifying an 8-bit mode such as CFB8 or OFB8, so a transformation such
//              as AES/CFB8/NoPadding can be used to encrypt data of any length.
//
//              The strength of the encryption depends on your choice of cipher alogrithm and key size.
//              AES uses a 128-bit (16 byte), 192-bit (24 byte), or 256-bit (32 byte) key. Specify 128, 192, or 256 as the keysize argument for
//              the KeyGenerator.init method.
//              To use AES with a 192-bit or 256-bit key, the Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files must be downloaded
//              from Oracle and installed in your JRE.
//              DESede uses a 192-bit (24 byte) key that is effectively either a 112-bit or 168-bit key. Specify 112 or 168 as the keysize argument for
//              the KeyGenerator.init method.
//
//              Resource Names
//              --------------
//
//              This program has command-line arguments PasswordEncryptionKeyFileName and EncryptedPasswordFileName to specify filenames.
//              In contrast, the Teradata JDBC Driver's "ENCRYPTED_PASSWORD(" syntax uses resource names, rather than filenames, in order to offer
//              more flexibility for file storage location and access.
//
//                ENCRYPTED_PASSWORD(PasswordEncryptionKeyResourceName,EncryptedPasswordResourceName)
//
//              Files created by this program are subsequently accessed as resources by the Teradata JDBC Driver.
//              The resource names include a prefix to indicate how the resource must be accessed.
//              If the resource name begins with the "classpath:" prefix, then the Teradata JDBC Driver loads the resource from the classpath.
//              If you specify a resource name with the "classpath:" prefix, then you must ensure the resource is available on the classpath for the Teradata JDBC Driver.
//              For security, classpath resources are required to have specific resource name prefixes.
//              The PasswordEncryptionKeyResourceName must begin with "PassKey" and the EncryptedPasswordResourceName must begin with "EncPass".
//
//              Example:
//
//                ENCRYPTED_PASSWORD(classpath:PassKeyJohnDoe.properties,classpath:EncPassJohnDoe.properties)
//
//              If the resource name begins with a prefix other than "classpath:", then the Teradata JDBC Driver loads the resource via the
//              new URL(resourcename).openStream() method. Non-classpath resources are not required to have specific resource name prefixes.
//              You must ensure that non-classpath resources are accessible by the Teradata JDBC Driver.
//
//              The resource name can begin with the "file:" prefix and specify a relative pathname for the Teradata JDBC Driver to load the resource
//              from a relative-pathname file.
//
//              Example with files in current directory:
//
//                ENCRYPTED_PASSWORD(file:JohnDoeKey.properties,file:JohnDoePass.properties)
//
//              Example with relative paths:
//
//                ENCRYPTED_PASSWORD(file:../dir1/JohnDoeKey.properties,file:../dir2/JohnDoePass.properties)
//
//              The resource name can begin with the "file:" prefix and specify an absolute pathname for the Teradata JDBC Driver to load the resource
//              from an absolute-pathname file.
//
//              Example with absolute paths on Windows:
//
//                ENCRYPTED_PASSWORD(file:c:/dir1/JohnDoeKey.properties,file:c:/dir2/JohnDoePass.properties)
//
//              Example with absolute paths on Linux:
//
//                ENCRYPTED_PASSWORD(file:/dir1/JohnDoeKey.properties,file:/dir2/JohnDoePass.properties)
//
//*********************************************************************

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.AlgorithmParameters;
import java.security.GeneralSecurityException;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Properties;

import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

public class TeraDataEncryPassKeyGenerator {
	public static final int BOUNDARY = 512;

	public static void main(String[] args)
			throws ClassNotFoundException, GeneralSecurityException, IOException, SQLException {
		if (args.length != 8)
			throw new IllegalArgumentException(
					"Parameters: Transformation KeySizeInBits MAC PasswordEncryptionKeyFileName EncryptedPasswordFileName Hostname Username Password");

		String sTransformation = args[0]; // transformation argument for the
											// Cipher.getInstance method
		String sKeySizeInBits = args[1]; // keysize argument for the
											// KeyGenerator.init method
		String sMac = args[2]; // algorithm argument for the Mac.getInstance
								// method
		String sPasswordEncryptionKeyFileName = args[3];
		String sEncryptedPasswordFileName = args[4];
		String sHostname = args[5];
		String sUsername = args[6];
		String sPassword = args[7];

		createPasswordEncryptionKeyFile(sTransformation, sKeySizeInBits, sMac, sPasswordEncryptionKeyFileName);

		createEncryptedPasswordFile(sPasswordEncryptionKeyFileName, sEncryptedPasswordFileName, sPassword);

		decryptPassword(sPasswordEncryptionKeyFileName, sEncryptedPasswordFileName);

		String sResource1 = "file:" + sPasswordEncryptionKeyFileName;
		String sResource2 = "file:" + sEncryptedPasswordFileName;

		String sEncryptedPassword = "ENCRYPTED_PASSWORD(" + sResource1 + "," + sResource2 + ")";

		Class.forName("com.teradata.jdbc.TeraDriver");

		String sURL = "jdbc:teradata://" + sHostname + "/TMODE=ANSI,CHARSET=UTF8";
		System.out.println("Connecting to " + sURL + " with user " + sUsername + " and password " + sEncryptedPassword);
		Connection con = DriverManager.getConnection(sURL, sUsername, sEncryptedPassword);

		DatabaseMetaData dbmd = con.getMetaData();
		System.out.println(
				"Teradata JDBC Driver " + dbmd.getDriverVersion() + " and " + dbmd.getDatabaseProductVersion());

		con.close();

	} // end main

	public static void createPasswordEncryptionKeyFile(String sTransformation, String sKeySizeInBits, String sMac,
			String sPasswordEncryptionKeyFileName) throws GeneralSecurityException, IOException {
		String sAlgorithm = sTransformation.replaceFirst("/.*", "");

		KeyGenerator kgCipher = KeyGenerator.getInstance(sAlgorithm);

		if (!"-default".equals(sKeySizeInBits))
			kgCipher.init(Integer.parseInt(sKeySizeInBits));

		SecretKey keyCipher = kgCipher.generateKey();

		KeyGenerator kgMac = KeyGenerator.getInstance(sMac);
		SecretKey keyMac = kgMac.generateKey();

		Properties props = new Properties();
		props.setProperty("version", "1");
		props.setProperty("match", new SimpleDateFormat("yyyyMMdd.HHmmss.SSS").format(new java.util.Date()));
		props.setProperty("transformation", sTransformation);
		props.setProperty("algorithm", sAlgorithm);
		props.setProperty("key", formatAsHexDigits(keyCipher.getEncoded()));
		props.setProperty("mac", sMac);
		props.setProperty("mackey", formatAsHexDigits(keyMac.getEncoded()));

		storePropertiesToFile(props, sPasswordEncryptionKeyFileName,
				"Teradata JDBC Driver password encryption key file");

	} // end createPasswordEncryptionKeyFile

	public static void createEncryptedPasswordFile(String sPasswordEncryptionKeyFileName,
			String sEncryptedPasswordFileName, String sPassword) throws GeneralSecurityException, IOException {
		if (sPassword.length() == 0)
			throw new IllegalArgumentException("Password cannot be a zero-length string");

		sPassword = decodeUnicodeEscapeSequences(sPassword);

		Properties propsKey = loadPropertiesFromFile(sPasswordEncryptionKeyFileName);

		String sVersionNumber = propsKey.getProperty("version");
		String sMatchValue = propsKey.getProperty("match");
		String sTransformation = propsKey.getProperty("transformation");
		String sAlgorithm = propsKey.getProperty("algorithm");
		byte[] abyKey = parseFromHexDigits(propsKey.getProperty("key"));
		String sMac = propsKey.getProperty("mac");
		byte[] abyMacKey = parseFromHexDigits(propsKey.getProperty("mackey"));

		if (!"1".equals(sVersionNumber))
			throw new IllegalArgumentException("Properties file " + sPasswordEncryptionKeyFileName
					+ " has unexpected or nonexistent version " + sVersionNumber);

		System.out.println(sPasswordEncryptionKeyFileName + " specifies " + sTransformation + " with "
				+ (abyKey.length * 8) + "-bit key" + ", then " + sMac);

		byte[] abyPassword = sPassword.getBytes("UTF-8");
		int nPlaintextByteCount = ((abyPassword.length / BOUNDARY) + 1) * BOUNDARY; // pad
																					// boundary
		int nTrailerByteCount = nPlaintextByteCount - abyPassword.length;

		ByteArrayOutputStream osPlaintext = new ByteArrayOutputStream();
		osPlaintext.write(abyPassword);
		osPlaintext.write(new byte[nTrailerByteCount]); // null bytes

		byte[] abyPlaintext = osPlaintext.toByteArray();

		SecretKeySpec keyCipher = new SecretKeySpec(abyKey, sAlgorithm);

		Cipher cipher = Cipher.getInstance(sTransformation);

		cipher.init(Cipher.ENCRYPT_MODE, keyCipher);

		byte[] abyCiphertext = cipher.doFinal(abyPlaintext);

		AlgorithmParameters params = cipher.getParameters();
		byte[] abyParams = params != null ? params.getEncoded() : null;

		ByteArrayOutputStream osContent = new ByteArrayOutputStream();
		osContent.write(abyCiphertext);
		osContent.write(sTransformation.getBytes("UTF-8"));
		if (abyParams != null)
			osContent.write(abyParams);

		SecretKeySpec keyMac = new SecretKeySpec(abyMacKey, sMac);

		Mac mac = Mac.getInstance(sMac);
		mac.init(keyMac);

		byte[] abyHash = mac.doFinal(osContent.toByteArray());

		Properties propsPassword = new Properties();
		propsPassword.setProperty("version", sVersionNumber);
		propsPassword.setProperty("match", sMatchValue);
		propsPassword.setProperty("password", formatAsHexDigits(abyCiphertext));
		propsPassword.setProperty("hash", formatAsHexDigits(abyHash));
		if (abyParams != null)
			propsPassword.setProperty("params", formatAsHexDigits(abyParams));

		storePropertiesToFile(propsPassword, sEncryptedPasswordFileName,
				"Teradata JDBC Driver encrypted password file");

	} // end createEncryptedPasswordFile

	public static void decryptPassword(String sPasswordEncryptionKeyFileName, String sEncryptedPasswordFileName)
			throws IOException, GeneralSecurityException {
		Properties propsKey = loadPropertiesFromFile(sPasswordEncryptionKeyFileName);
		Properties propsPassword = loadPropertiesFromFile(sEncryptedPasswordFileName);

		String sVersionNumberA = propsKey.getProperty("version");
		String sMatchValueA = propsKey.getProperty("match");
		String sTransformation = propsKey.getProperty("transformation");
		String sAlgorithm = propsKey.getProperty("algorithm");
		byte[] abyKey = parseFromHexDigits(propsKey.getProperty("key"));
		String sMac = propsKey.getProperty("mac");
		byte[] abyMacKey = parseFromHexDigits(propsKey.getProperty("mackey"));

		String sVersionNumberB = propsPassword.getProperty("version");
		String sMatchValueB = propsPassword.getProperty("match");
		byte[] abyCiphertext = parseFromHexDigits(propsPassword.getProperty("password"));
		byte[] abyExpectedHash = parseFromHexDigits(propsPassword.getProperty("hash"));
		String sParams = propsPassword.getProperty("params");
		byte[] abyParams = sParams != null ? parseFromHexDigits(sParams) : null;

		if (!"1".equals(sVersionNumberA))
			throw new IllegalArgumentException("Properties file " + sPasswordEncryptionKeyFileName
					+ " has unexpected or nonexistent version " + sVersionNumberA);

		if (!"1".equals(sVersionNumberB))
			throw new IllegalArgumentException("Properties file " + sEncryptedPasswordFileName
					+ " has unexpected or nonexistent version " + sVersionNumberB);

		if (sMatchValueA == null)
			throw new IllegalArgumentException(
					"Properties file " + sPasswordEncryptionKeyFileName + " is missing a match value");

		if (sMatchValueB == null)
			throw new IllegalArgumentException(
					"Properties file " + sEncryptedPasswordFileName + " is missing a match value");

		if (!sMatchValueA.equals(sMatchValueB))
			throw new IllegalArgumentException("Properties file " + sPasswordEncryptionKeyFileName + " match value "
					+ sMatchValueA + " differs from properties file " + sEncryptedPasswordFileName + " match value "
					+ sMatchValueB);

		ByteArrayOutputStream osContent = new ByteArrayOutputStream();
		osContent.write(abyCiphertext);
		osContent.write(sTransformation.getBytes("UTF-8"));
		if (abyParams != null)
			osContent.write(abyParams);

		SecretKeySpec keyMac = new SecretKeySpec(abyMacKey, sMac);

		Mac mac = Mac.getInstance(sMac);
		mac.init(keyMac);

		byte[] abyActualHash = mac.doFinal(osContent.toByteArray());
		if (!Arrays.equals(abyExpectedHash, abyActualHash))
			throw new IllegalArgumentException("Hash mismatch indicates possible tampering with properties file "
					+ sPasswordEncryptionKeyFileName + " and/or " + sEncryptedPasswordFileName);

		Cipher cipher = Cipher.getInstance(sTransformation);

		SecretKeySpec keyCipher = new SecretKeySpec(abyKey, sAlgorithm);

		AlgorithmParameters params = abyParams != null ? AlgorithmParameters.getInstance(sAlgorithm) : null;
		if (params != null)
			params.init(abyParams);

		cipher.init(Cipher.DECRYPT_MODE, keyCipher, params);

		byte[] abyPlaintext = cipher.doFinal(abyCiphertext);

		int nDecodeCount = 0;
		while (abyPlaintext[nDecodeCount] != 0) // find the null byte
			nDecodeCount++;

		String sDecryptedPassword = new String(abyPlaintext, 0, nDecodeCount, "UTF-8");

		System.out.println("Decrypted password: " + sDecryptedPassword);

	} // end decryptPassword

	public static void storePropertiesToFile(Properties props, String sFileName, String sTitle) throws IOException {
		OutputStream os = new FileOutputStream(sFileName);
		try {
			props.store(os, sTitle);
		} finally {
			os.close();
		}

		System.out.println("Created " + sFileName);

	} // end storePropertiesToFile

	public static Properties loadPropertiesFromFile(String sFileName) throws IOException {
		Properties props = new Properties();
		InputStream is = new FileInputStream(sFileName);
		try {
			props.load(is);
		} finally {
			is.close();
		}

		return props;

	} // end loadPropertiesFromFile

	public static String formatAsHexDigits(byte[] aby) {
		String sOutput = "";
		for (int i = 0; i < aby.length; i++) {
			String s = Integer.toHexString(aby[i] & 0xFF);
			sOutput += (s.length() < 2 ? "0" : "") + s;
		}

		return sOutput;

	} // end formatAsHexDigits

	public static byte[] parseFromHexDigits(String s) {
		if ((s.length() & 1) != 0)
			throw new IllegalArgumentException("Odd number of characters: " + s.length());

		byte[] aby = new byte[s.length() / 2];
		for (int i = 0; i < aby.length; i++)
			aby[i] = (byte) Integer.parseInt(s.substring(i * 2, i * 2 + 2), 16);

		return aby;

	} // end parseFromHexDigits

	public static String decodeUnicodeEscapeSequences(String s) {
		String sOutput = "";
		for (int i = 0; i < s.length();) {
			if (s.regionMatches(i, "\\u", 0, 2)) {
				String sHexDigits = s.substring(i + 2, i + 6);
				char c = (char) Integer.parseInt(sHexDigits, 16);
				sOutput += c;
				i += 6;
			} else {
				sOutput += s.charAt(i);
				i++;
			}
		}

		return sOutput;

	} // end decodeUnicodeEscapeSequences

} // end class TJEncryptPassword


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&NEWWW&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.apiutils.jwt;

import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Security;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;

import org.bouncycastle.jcajce.provider.asymmetric.rsa.BCRSAPrivateCrtKey;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

public class KeyDecoder {
	private final String BEGIN_RSA_PRIVATE_KEY = "-----BEGIN RSA PRIVATE KEY-----";
	private final String END_RSA_PRIVATE_KEY = "-----END RSA PRIVATE KEY-----";
	private String rsaPrivateKey;
	private KeyPair keyPair;

	static {
		Security.addProvider(new BouncyCastleProvider());
	}

	public KeyDecoder(String privateKey) {
		privateKey = privateKey.replaceAll("\\n", "").replaceAll("\\r", "");
		rsaPrivateKey = privateKey.replace(BEGIN_RSA_PRIVATE_KEY, "").replace(END_RSA_PRIVATE_KEY, "");
		generateKeyPair(rsaPrivateKey);
	}

	public PrivateKey getPrivateKey() {
		return keyPair.getPrivate();
	}

	public PublicKey getPublicKey() {
		return keyPair.getPublic();
	}

	private void generateKeyPair(String privateKey) {
		byte[] privateKeyBytes = Base64.getMimeDecoder().decode(privateKey);
		BCRSAPrivateCrtKey pvtKey = (BCRSAPrivateCrtKey) fetchPrivateKey(privateKeyBytes);
		PublicKey pubKey = null;

		try {
			RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(pvtKey.getModulus(), pvtKey.getPublicExponent());
			KeyFactory keyFactory = KeyFactory.getInstance("RSA");
			pubKey = keyFactory.generatePublic(publicKeySpec);
		} catch (NoSuchAlgorithmException | InvalidKeySpecException e) {
			e.printStackTrace();
		}

		keyPair = new KeyPair(pubKey, pvtKey);
	}

	private PrivateKey fetchPrivateKey(byte[] privateKeyBytes) {
		try {
			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(privateKeyBytes);
			KeyFactory kf = KeyFactory.getInstance("RSA");
			return kf.generatePrivate(spec);
		} catch (InvalidKeySpecException | NoSuchAlgorithmException e) {
			e.printStackTrace();
			return null;
		}
	}

//	public String extract(String privateKeyString) throws Exception {
//		BCRSAPrivateCrtKey rsaPrivateKey = null;// (BCRSAPrivateCrtKey) getPrivateKey(privateKeyString);
//
//		@SuppressWarnings("null")
//		RSAPublicKey publicKey = (RSAPublicKey) KeyFactory.getInstance("RSA")
//				.generatePublic(new RSAPublicKeySpec(rsaPrivateKey.getModulus(), rsaPrivateKey.getPublicExponent()));
//
//		byte[] bytes = encodePublicKey(publicKey);
//		return "ssh-rsa " + new String(Base64.getEncoder().encode(bytes), StandardCharsets.UTF_8) + " some@user";
//	}
//
//	private byte[] encodePublicKey(RSAPublicKey key) throws IOException {
//		ByteArrayOutputStream out = new ByteArrayOutputStream();
//		/* encode the "ssh-rsa" string */
//		byte[] sshrsa = new byte[] { 0, 0, 0, 7, 's', 's', 'h', '-', 'r', 's', 'a' };
//		out.write(sshrsa);
//		/* Encode the public exponent */
//		BigInteger e = key.getPublicExponent();
//		byte[] data = e.toByteArray();
//		encodeUInt32(data.length, out);
//		out.write(data);
//		/* Encode the modulus */
//		BigInteger m = key.getModulus();
//		data = m.toByteArray();
//		encodeUInt32(data.length, out);
//		out.write(data);
//		return out.toByteArray();
//	}
//
//	private void encodeUInt32(int value, OutputStream out) throws IOException {
//		byte[] tmp = new byte[4];
//		tmp[0] = (byte) ((value >>> 24) & 0xff);
//		tmp[1] = (byte) ((value >>> 16) & 0xff);
//		tmp[2] = (byte) ((value >>> 8) & 0xff);
//		tmp[3] = (byte) (value & 0xff);
//		out.write(tmp);
//	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.apiutils.jwt;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.io.FileUtils;

import com.google.gson.Gson;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.gson.io.GsonSerializer;

public class JwtsUtility {
	private String privateKey;
	private JwtsStructure jwtRaw;
	private JwtsType keyType;

	public enum JwtsType {
		JWT, JWS
	}

	public JwtsUtility(File keyFile, String payload, JwtsType jwtsType) {
		try {
			privateKey = FileUtils.readFileToString(keyFile, StandardCharsets.UTF_8).trim();
			jwtRaw = new Gson().fromJson(payload, JwtsStructure.class);
			keyType = jwtsType;
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public String generateJwt() {
		KeyDecoder keyDecoder = new KeyDecoder(privateKey);
		String jws = Jwts.builder().serializeToJsonWith(new GsonSerializer<Map<String, ?>>()).setHeader(getJwtHeader())
				.setClaims(getJwtPayload()).signWith(keyDecoder.getPrivateKey(), SignatureAlgorithm.PS256).compact();

		return jws;
	}

	public String generateJws() {
		KeyDecoder keyDecoder = new KeyDecoder(privateKey);
		String jws = Jwts.builder().serializeToJsonWith(new GsonSerializer<Map<String, ?>>()).setHeader(getJwsHeader())
				.setClaims(getJwsPayload()).signWith(keyDecoder.getPrivateKey(), SignatureAlgorithm.PS256).compact();

		return jws;
	}

	private Map<String, Object> getJwtHeader() {
		Map<String, Object> headerMap = new HashMap<>();
		headerMap.put("alg", jwtRaw.getHeader().getAlgorithm());
		headerMap.put("typ", jwtRaw.getHeader().getType());
		headerMap.put("kid", jwtRaw.getHeader().getKId());

		return headerMap;
	}

	private Claims getJwtPayload() {
		Claims openbanking_claims = Jwts.claims();
		openbanking_claims.put("value",
				jwtRaw.getPayload().getClaims().getIdToken().getOpenBankingIntentId().getConsentId());
		openbanking_claims.put("essential",
				jwtRaw.getPayload().getClaims().getIdToken().getOpenBankingIntentId().isEssential());

		Claims openbanking_intent_id = Jwts.claims();
		openbanking_intent_id.put("openbanking_intent_id", openbanking_claims);

		Claims id_token = Jwts.claims();
		id_token.put("id_token", openbanking_intent_id);

		Claims jwtClaims = Jwts.claims();
		jwtClaims.put("iss", jwtRaw.getPayload().getIssuer());
		jwtClaims.put("aud", jwtRaw.getPayload().getAudience());
		jwtClaims.put("response_type", jwtRaw.getPayload().getResponseType());
		jwtClaims.put("client_id", jwtRaw.getPayload().getClientId());
		jwtClaims.put("redirect_uri", jwtRaw.getPayload().getRedirectUri());
		jwtClaims.put("scope", jwtRaw.getPayload().getScope());
		jwtClaims.put("state", jwtRaw.getPayload().getState());
		jwtClaims.put("nonce", jwtRaw.getPayload().getNonce());
		jwtClaims.put("exp", jwtRaw.getPayload().getExpire());
		jwtClaims.put("max_age", jwtRaw.getPayload().getMaxAge());
		jwtClaims.put("claims", id_token);

		return jwtClaims;
	}

	private Map<String, Object> getJwsHeader() {
		Map<String, Object> headerMap = new HashMap<>();
		headerMap.put("alg", jwtRaw.getHeader().getAlgorithm());
		headerMap.put("typ", jwtRaw.getHeader().getType());
		headerMap.put("kid", jwtRaw.getHeader().getKId());
		headerMap.put("b64", jwtRaw.getHeader().isB64());
		headerMap.put("cty", jwtRaw.getHeader().getCty());
		headerMap.put(String.format(jwtRaw.getHeader().getIatKey()), jwtRaw.getHeader().getIat());
		headerMap.put(String.format(jwtRaw.getHeader().getIssKey()), jwtRaw.getHeader().getIss());
		headerMap.put(String.format(jwtRaw.getHeader().getTanKey()), jwtRaw.getHeader().getTan());
		headerMap.put("crit", jwtRaw.getHeader().getCrit());

		return headerMap;
	}

	private Claims getJwsPayload() {
		Claims jwsClaims = Jwts.claims();

		Claims remittanceInformationClaims = Jwts.claims();
		remittanceInformationClaims.put("Unstructured",
				jwtRaw.getPayload().getData().getInitiation().getRemittanceInformation().getUnstructured());
		remittanceInformationClaims.put("Reference",
				jwtRaw.getPayload().getData().getInitiation().getRemittanceInformation().getReference());

		Claims creditorAccountClaims = Jwts.claims();
		creditorAccountClaims.put("SchemeName",
				jwtRaw.getPayload().getData().getInitiation().getCreditorAccount().getSchemeName());
		creditorAccountClaims.put("Identification",
				jwtRaw.getPayload().getData().getInitiation().getCreditorAccount().getIdentification());
		creditorAccountClaims.put("Name", jwtRaw.getPayload().getData().getInitiation().getCreditorAccount().getName());
		creditorAccountClaims.put("SecondaryIdentification",
				jwtRaw.getPayload().getData().getInitiation().getCreditorAccount().getSecondaryIdentification());

		Claims instructedAmountClaims = Jwts.claims();
		instructedAmountClaims.put("Amount",
				jwtRaw.getPayload().getData().getInitiation().getInstructedAmount().getAmount());
		instructedAmountClaims.put("Currency",
				jwtRaw.getPayload().getData().getInitiation().getInstructedAmount().getCurrency());

		Claims initiationClaims = Jwts.claims();
		initiationClaims.put("InstructionIdentification",
				jwtRaw.getPayload().getData().getInitiation().getInstructionIdentification());
		initiationClaims.put("EndToEndIdentification",
				jwtRaw.getPayload().getData().getInitiation().getEndToEndIdentification());
		initiationClaims.put("InstructedAmount", instructedAmountClaims);
		initiationClaims.put("CreditorAccount", creditorAccountClaims);
		initiationClaims.put("RemittanceInformation", remittanceInformationClaims);

		Claims dataClaims = Jwts.claims();
		dataClaims.put("ConsentId", jwtRaw.getPayload().getData().getConsentId());
		dataClaims.put("Initiation", initiationClaims);

		Claims deliveryAddressClaims = Jwts.claims();
		deliveryAddressClaims.put("TownName", jwtRaw.getPayload().getRisk().getDeliveryAddress().getTownName());
		deliveryAddressClaims.put("Country", jwtRaw.getPayload().getRisk().getDeliveryAddress().getCountry());

		jwsClaims.put("Data", dataClaims);
		jwsClaims.put("Risk", deliveryAddressClaims);

		return jwsClaims;
	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&7

package com.boi.grp.utilities.apiutils.jwt;

public class JwtsStructure {
	private JwsHeader header;
	private JwsPayload payload;

	public JwsHeader getHeader() {
		return header;
	}

	public JwsPayload getPayload() {
		return payload;
	}

	public class JwsHeader {
		private String alg;
		private String typ;
		private String kid;
		private boolean b64;
		private long iat;
		private String iss;
		private String tan;
		private String cty;

		public String getAlgorithm() {
			return alg;
		}

		public String getType() {
			return typ;
		}

		public String getKId() {
			return kid;
		}

		public boolean isB64() {
			return b64;
		}

		public long getIat() {
			return iat;
		}

		public String getIatKey() {
			return String.format("http://%s/iat", tan);
		}

		public String getIss() {
			return iss;
		}

		public String getIssKey() {
			return String.format("http://%s/iss", tan);
		}

		public String getTan() {
			return tan;
		}

		public String getTanKey() {
			return String.format("http://%s/tan", tan);
		}

		public String getCty() {
			return cty;
		}

		public String[] getCrit() {
			return new String[] { "b64", getIatKey(), getIssKey(), getTanKey() };
		}
	}

	public class JwsPayload {
		private String iss;
		private String aud;
		private String response_type;
		private String client_id;
		private String redirect_uri;
		private String scope;
		private String state;
		private String nonce;
		private long exp;
		private long max_age;
		private Claims claims;
		private JwsData Data;
		private JwsRisk Risk;

		public JwsData getData() {
			return Data;
		}

		public JwsRisk getRisk() {
			return Risk;
		}

		public String getIssuer() {
			return iss;
		}

		public String getAudience() {
			return aud;
		}

		public String getResponseType() {
			return response_type;
		}

		public String getClientId() {
			return client_id;
		}

		public String getRedirectUri() {
			return redirect_uri;
		}

		public String getScope() {
			return scope;
		}

		public String getState() {
			return state;
		}

		public String getNonce() {
			return nonce;
		}

		public long getExpire() {
			return exp;
		}

		public long getMaxAge() {
			return max_age;
		}

		public Claims getClaims() {
			return claims;
		}
	}

	public class JwsData {
		private JwsInitiation Initiation;
		private String ConsentId;

		public String getConsentId() {
			return ConsentId;
		}

		public JwsInitiation getInitiation() {
			return Initiation;
		}
	}

	public class JwsInitiation {
		private String InstructionIdentification;
		private String EndToEndIdentification;
		private JwsInstructedAmount InstructedAmount;
		private JwsCreditorAccount CreditorAccount;
		private JwsRemittanceInformation RemittanceInformation;

		public String getInstructionIdentification() {
			return InstructionIdentification;
		}

		public String getEndToEndIdentification() {
			return EndToEndIdentification;
		}

		public JwsInstructedAmount getInstructedAmount() {
			return InstructedAmount;
		}

		public JwsCreditorAccount getCreditorAccount() {
			return CreditorAccount;
		}

		public JwsRemittanceInformation getRemittanceInformation() {
			return RemittanceInformation;
		}
	}

	public class JwsInstructedAmount {
		private String Amount;
		private String Currency;

		public String getAmount() {
			return Amount;
		}

		public String getCurrency() {
			return Currency;
		}
	}

	public class JwsCreditorAccount {
		private String SchemeName;
		private String Identification;
		private String Name;
		private String SecondaryIdentification;

		public String getSchemeName() {
			return SchemeName;
		}

		public String getIdentification() {
			return Identification;
		}

		public String getName() {
			return Name;
		}

		public String getSecondaryIdentification() {
			return SecondaryIdentification;
		}
	}

	public class JwsRemittanceInformation {
		private String Unstructured;
		private String Reference;

		public String getUnstructured() {
			return Unstructured;
		}

		public String getReference() {
			return Reference;
		}
	}

	public class JwsRisk {
		private JwsDeliveryAddress DeliveryAddress;

		public JwsDeliveryAddress getDeliveryAddress() {
			return DeliveryAddress;
		}
	}

	public class JwsDeliveryAddress {
		private String TownName;
		private String Country;

		public String getTownName() {
			return TownName;
		}

		public String getCountry() {
			return Country;
		}
	}

	public class Claims {
		private Token id_token;

		public Token getIdToken() {
			return id_token;
		}
	}

	public class Token {
		private OpenBankingIntent openbanking_intent_id;

		public OpenBankingIntent getOpenBankingIntentId() {
			return openbanking_intent_id;
		}
	}

	public class OpenBankingIntent {
		private String value;
		private boolean essential;

		public String getConsentId() {
			return value;
		}

		public boolean isEssential() {
			return essential;
		}
	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&NEW


package com.boi.grp.utilities.faker.enums;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * An enum for the fields supported by JavaFaker
 * 
 * @author A113845
 *
 */
public enum FakerField {
	CITY(FakerFieldType.FAKER_DATA_EXTENSION, "City", "city"),
	CITY_NAME(FakerFieldType.FAKER_DATA_EXTENSION, "City Name", "cityName"),
	FULL_ADDRESS(FakerFieldType.FAKER_DATA_EXTENSION, "Full Address", "fullAddress"),
	STATE(FakerFieldType.FAKER_DATA_EXTENSION, "State", "state"),
	STATE_ABBR(FakerFieldType.FAKER_DATA_EXTENSION, "State Abbr", "stateAbbr"),
	ZIP_CODE(FakerFieldType.FAKER_DATA_EXTENSION, "Zip Code", "zipCode"),
	IBAN(FakerFieldType.FAKER_DATA_EXTENSION, "Iban", "iban"),
	CELL_PHONE(FakerFieldType.FAKER_DATA_EXTENSION, "Cell Phone", "phoneNumber"),
	PHONE_NUMBER(FakerFieldType.FAKER_DATA_EXTENSION, "Phone Number", "phoneNumber"),

	BUILDING_NUMBER(FakerFieldType.ADDRESS, "Building Number", "buildingNumber"),
	CITY_PREFIX(FakerFieldType.ADDRESS, "City Prefix", "cityPrefix"),
	CITY_SUFFIX(FakerFieldType.ADDRESS, "City Suffix", "citySuffix"),
	COUNTRY(FakerFieldType.ADDRESS, "Country", "country"),
	COUNTRY_CODE(FakerFieldType.ADDRESS, "Country Code", "countryCode"),
	LATITUDE(FakerFieldType.ADDRESS, "Latitude", "latitude"),
	LONGITUDE(FakerFieldType.ADDRESS, "Longitude", "longitude"),
	SECONDARY_ADDRESS(FakerFieldType.ADDRESS, "Secondary Address", "secondaryAddress"),
	STREET_ADDRESS(FakerFieldType.ADDRESS, "Street Address", "streetAddress"),
	STREET_ADDRESS_NUMBER(FakerFieldType.ADDRESS, "Street Address Number", "streetAddressNumber"),
	STREET_NAME(FakerFieldType.ADDRESS, "Street Name", "streetName"),
	STREET_PREFIX(FakerFieldType.ADDRESS, "Street Prefix", "streetPrefix"),
	STREET_SUFFIX(FakerFieldType.ADDRESS, "Street Suffix", "streetSuffix"),
	TIME_ZONE(FakerFieldType.ADDRESS, "Time Zone", "timeZone"),

	CREDIT_CARD_EXPIRY(FakerFieldType.BUSINESS, "Credit Card Expiry", "creditCardExpiry"),
	CREDIT_CARD_NUMBER(FakerFieldType.BUSINESS, "Credit Card Number", "creditCardNumber"),
	CREDIT_CARD_TYPE(FakerFieldType.BUSINESS, "Credit Card Type", "creditCardType"),

	ASIN(FakerFieldType.CODE, "Asin", "asin"), EAN13(FakerFieldType.CODE, "Ean13", "ean13"),
	EAN8(FakerFieldType.CODE, "Ean8", "ean8"), GTIN13(FakerFieldType.CODE, "Gtin13", "gtin13"),
	GTIN8(FakerFieldType.CODE, "Gtin8", "gtin8"), IMEI(FakerFieldType.CODE, "Imei", "imei"),
	ISBN10(FakerFieldType.CODE, "Isbn10", "isbn10"), ISBN13(FakerFieldType.CODE, "Isbn13", "isbn13"),
	ISBN_GROUP(FakerFieldType.CODE, "Isbn Group", "isbnGroup"), ISBN_GS1(FakerFieldType.CODE, "Isbn Gs1", "isbnGs1"),
	ISBN_REGISTRANT(FakerFieldType.CODE, "Isbn Registrant", "isbnRegistrant"),

	BS(FakerFieldType.COMPANY, "Bs", "bs"), BUZZWORD(FakerFieldType.COMPANY, "Buzzword", "buzzword"),
	CATCH_PHRASE(FakerFieldType.COMPANY, "Catch Phrase", "catchPhrase"),
	INDUSTRY(FakerFieldType.COMPANY, "Industry", "industry"), LOGO(FakerFieldType.COMPANY, "Logo", "logo"),
	COMPANY_NAME(FakerFieldType.COMPANY, "Name", "name"),
	PROFESSION(FakerFieldType.COMPANY, "Profession", "profession"),
	COMPANY_SUFFIX(FakerFieldType.COMPANY, "Suffix", "suffix"), COMPANY_URL(FakerFieldType.COMPANY, "Url", "url"),

	CAPITAL(FakerFieldType.COUNTRY, "Capital", "capital"),
	COUNTRY_CODE2(FakerFieldType.COUNTRY, "Country Code2", "countryCode2"),
	COUNTRY_CODE3(FakerFieldType.COUNTRY, "Country Code3", "countryCode3"),
	CURRENCY(FakerFieldType.COUNTRY, "Currency", "currency"),
	CURRENCY_CODE(FakerFieldType.COUNTRY, "Currency Code", "currencyCode"),
	FLAG(FakerFieldType.COUNTRY, "Flag", "flag"), COUNTRY_NAME(FakerFieldType.COUNTRY, "Name", "name"),

	BIRTHDAY(FakerFieldType.DATE_TIME, "Birthday", "birthday"),

	DEMONYM(FakerFieldType.DEMOGRAPHIC, "Demonym", "demonym"),
	EDUCATIONAL_ATTAINMENT(FakerFieldType.DEMOGRAPHIC, "Educational Attainment", "educationalAttainment"),
	MARITAL_STATUS(FakerFieldType.DEMOGRAPHIC, "Marital Status", "maritalStatus"),
	RACE(FakerFieldType.DEMOGRAPHIC, "Race", "race"), SEX(FakerFieldType.DEMOGRAPHIC, "Sex", "sex"),

	BIC(FakerFieldType.FINANCE, "Bic", "bic"), CREDIT_CARD(FakerFieldType.FINANCE, "Credit Card", "creditCard"),

	INVALID(FakerFieldType.ID_NUMBER, "Invalid", "invalid"),
	SSN_VALID(FakerFieldType.ID_NUMBER, "Ssn Valid", "ssnValid"), VALID(FakerFieldType.ID_NUMBER, "Valid", "valid"),

	DOMAIN_NAME(FakerFieldType.INTERNET, "Domain Name", "domainName"),
	DOMAIN_SUFFIX(FakerFieldType.INTERNET, "Domain Suffix", "domainSuffix"),
	DOMAIN_WORD(FakerFieldType.INTERNET, "Domain Word", "domainWord"),
	EMAIL_ADDRESS(FakerFieldType.INTERNET, "Email Address", "emailAddress"),
	IMAGE(FakerFieldType.INTERNET, "Image", "image"),
	IP_V4_ADDRESS(FakerFieldType.INTERNET, "Ip V4 Address", "ipV4Address"),
	IP_V4_CIDR(FakerFieldType.INTERNET, "Ip V4 Cidr", "ipV4Cidr"),
	IP_V6_ADDRESS(FakerFieldType.INTERNET, "Ip V6 Address", "ipV6Address"),
	IP_V6_CIDR(FakerFieldType.INTERNET, "Ip V6 Cidr", "ipV6Cidr"),
	MAC_ADDRESS(FakerFieldType.INTERNET, "Mac Address", "macAddress"),
	PASSWORD(FakerFieldType.INTERNET, "Password", "password"),
	PRIVATE_IP_V4_ADDRESS(FakerFieldType.INTERNET, "Private Ip V4 Address", "privateIpV4Address"),
	PUBLIC_IP_V4_ADDRESS(FakerFieldType.INTERNET, "Public Ip V4 Address", "publicIpV4Address"),
	SAFE_EMAIL_ADDRESS(FakerFieldType.INTERNET, "Safe Email Address", "safeEmailAddress"),
	SLUG(FakerFieldType.INTERNET, "Slug", "slug"), URL(FakerFieldType.INTERNET, "Url", "url"),
	USER_AGENT_ANY(FakerFieldType.INTERNET, "User Agent Any", "userAgentAny"),
	UUID(FakerFieldType.INTERNET, "Uuid", "uuid"),

	FIELD(FakerFieldType.JOB, "Field", "field"), KEY_SKILLS(FakerFieldType.JOB, "Key Skills", "keySkills"),
	POSITION(FakerFieldType.JOB, "Position", "position"), SENIORITY(FakerFieldType.JOB, "Seniority", "seniority"),
	JOB_TITLE(FakerFieldType.JOB, "Title", "title"),

	BLOOD_GROUP(FakerFieldType.NAME, "Blood Group", "bloodGroup"),
	FIRST_NAME(FakerFieldType.NAME, "First Name", "firstName"), FULL_NAME(FakerFieldType.NAME, "Full Name", "fullName"),
	LAST_NAME(FakerFieldType.NAME, "Last Name", "lastName"), NAME(FakerFieldType.NAME, "Name", "name"),
	WITH_MIDDLE_NAME(FakerFieldType.NAME, "With Middle Name", "nameWithMiddle"),
	PREFIX(FakerFieldType.NAME, "Prefix", "prefix"), SUFFIX(FakerFieldType.NAME, "Suffix", "suffix"),
	TITLE(FakerFieldType.NAME, "Title", "title"), USERNAME(FakerFieldType.NAME, "Username", "username"),

	CAPITAL_CITY(FakerFieldType.NATION, "Capital City", "capitalCity"),
	LANGUAGE(FakerFieldType.NATION, "Language", "language"),
	NATIONALITY(FakerFieldType.NATION, "Nationality", "nationality"),

	DIGIT(FakerFieldType.NUMBER, "Digit", "digit"),
	RANDOM_NUMBER(FakerFieldType.NUMBER, "Random Number", "randomNumber"),
	RANDOM_DIGIT(FakerFieldType.NUMBER, "Random Digit", "randomDigit"),
	RANDOM_DIGIT_NON_ZERO(FakerFieldType.NUMBER, "Non Zero Digit", "randomDigitNotZero"),

	EXTENSION(FakerFieldType.PHONE_NUMBER, "Extension", "extension"),
	SUBSCRIBER_NUMBER(FakerFieldType.PHONE_NUMBER, "Subscriber Number", "subscriberNumber");

	private String reflectionMethodName;
	private String fieldName;
	private FakerFieldType parentField;

	private FakerField(FakerFieldType parentType, String fName, String inlineMethodName) {
		reflectionMethodName = inlineMethodName;
		parentField = parentType;
		fieldName = fName;
	}

	public String getReflection() {
		return reflectionMethodName;
	}

	public Class<?> getFakerClass() {
		return parentField.getFakerClass();
	}

	public FakerFieldType getParent() {
		return parentField;
	}

	public String getMethodName() {
		return reflectionMethodName;
	}

	/**
	 * To get a list of all FakerFields tagged to a specific group
	 * 
	 * @param parentType - Parent group of fields
	 * @return A list of enum objects
	 */
	public static List<FakerField> getAllFields(FakerFieldType parentType) {
		List<FakerField> result = Stream.of(values()).filter(fkrFld -> fkrFld.parentField.equals(parentType))
				.collect(Collectors.toList());
		return result;
	}

	public static List<FakerField> getFields(List<String> fieldNames) {
		List<FakerField> result = Stream.of(values()).filter(fkrFld -> fieldNames.contains(fkrFld.toString()))
				.collect(Collectors.toList());
		return result;
	}

	public static List<FakerField> getFields(String[] fieldNames) {
		return getFields(Arrays.asList(fieldNames));
	}

	@Override
	public String toString() {
		return fieldName;
	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.faker.enums;

import com.boi.grp.utilities.faker.extender.FakerDataExtension;
import com.github.javafaker.Address;
import com.github.javafaker.Business;
import com.github.javafaker.Code;
import com.github.javafaker.Company;
import com.github.javafaker.Country;
import com.github.javafaker.DateAndTime;
import com.github.javafaker.Demographic;
import com.github.javafaker.Finance;
import com.github.javafaker.IdNumber;
import com.github.javafaker.Internet;
import com.github.javafaker.Job;
import com.github.javafaker.Name;
import com.github.javafaker.Nation;
import com.github.javafaker.Number;
import com.github.javafaker.Options;
import com.github.javafaker.PhoneNumber;

/**
 * An enum for the parent groups of the fields supported by JavaFaker
 * 
 * @author A113845
 *
 */

public enum FakerFieldType {
	ADDRESS("Address", "address", Address.class), BUSINESS("Business", "business", Business.class),
	CODE("Code", "code", Code.class), COMPANY("Company", "company", Company.class),
	COUNTRY("Country", "country", Country.class), DATE_TIME("Date Time", "date", DateAndTime.class),
	DEMOGRAPHIC("Demographic", "demographic", Demographic.class), FINANCE("Finance", "finance", Finance.class),
	ID_NUMBER("Id Number", "idNumber", IdNumber.class), INTERNET("Internet", "internet", Internet.class),
	JOB("Job", "job", Job.class), NAME("Name", "name", Name.class), NATION("Nation", "nation", Nation.class),
	NUMBER("Number", "number", Number.class), OPTIONS("Options", "options", Options.class),
	PHONE_NUMBER("Phone Number", "phoneNumber", PhoneNumber.class),
	FAKER_DATA_EXTENSION("Faker Data Extension", "dataExtenstion", FakerDataExtension.class);

	private String reflectionMethodName;
	private FakerFieldType parentField;
	private Class<?> fakerClass;
	private String fieldTypeName;

	private FakerFieldType(String typeName, String inlineMethodName, Class<?> fkrClass) {
		reflectionMethodName = inlineMethodName;
		fakerClass = fkrClass;
		parentField = null;
		fieldTypeName = typeName;
	}

	public String getReflection() {
		return reflectionMethodName;
	}

	public boolean isRootNode() {
		return parentField == null;
	}

	public FakerFieldType getParent() {
		return parentField;
	}

	public Class<?> getFakerClass() {
		return fakerClass;
	}

	public String getMethodName() {
		return reflectionMethodName;
	}

	@Override
	public String toString() {
		return fieldTypeName;
	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.faker.enums;

import java.util.Locale;

/**
 * An enum for to configure the locale to generate data using JavaFaker
 * 
 * @author A113845
 *
 */

public enum FakerLocale {

	ENGLISH_UK("en_UK"), ENGLISH_IE("en_IE"), IRISH("ga_IE");

	private String locale;
	private String countryCode;

	private FakerLocale(String localeCode) {
		locale = localeCode;
		if (localeCode.contains("_")) {
			String[] localeSplits = localeCode.split("_");
			countryCode = localeSplits[localeSplits.length - 1];
		} else {
			countryCode = localeCode;
		}
	}

	private FakerLocale(String localeCode, String countryCode) {
		locale = localeCode;
		this.countryCode = countryCode;
	}

	@Override
	public String toString() {
		return locale;
	}

	/**
	 * To get the default locale from the enum.
	 * 
	 * @return An enum object for Locale
	 */
	public static FakerLocale getDefault() {
		return ENGLISH_IE;
	}

	public Locale getLocale() {
		return new Locale(locale);
	}

	public String getCountryCode() {
		return countryCode;
	};
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.faker.extender;

import java.math.BigInteger;
import java.util.Map;

import org.apache.commons.lang3.StringUtils;

import com.google.gson.Gson;
import com.google.gson.JsonObject;
import com.jayway.jsonpath.PathNotFoundException;

/*
**
* @author A113845
*
*/

public class FakerDataExtension {
	private final FakerExtension faker;

	protected FakerDataExtension(FakerExtension faker) {
		this.faker = faker;
		faker.getLoale().toString();
	}

	public String fullAddress() {
		String streetAddress = faker.address().streetAddress();
		String secStreetAddress = faker.address().secondaryAddress();
		// String buildingNum = faker.address().buildingNumber();
		String zipCode = zipCode();
		String postalId = zipCode.split(" ")[0];
		Map<String, String> countyInfo = getCountyData(postalId);
		String city = countyInfo.get("city");
		String county = countyInfo.get("county");

		return String.format("%s; %s; %s; %s %s", streetAddress, secStreetAddress, city,
				county.length() > 0 ? "Co. " + county : "", zipCode);
	}

	public String state() {
		String zipCode = getEirCode();
		Map<String, String> countyInfo = getCountyData(zipCode);
		return countyInfo.get("county").toString();
	}

	public String stateAbbr() {
		return state();
	}

	public String city() {
		String zipCode = getEirCode();
		Map<String, String> countyInfo = getCountyData(zipCode);
		return countyInfo.get("city").toString();
	}

	public String cityName() {
		String zipCode = getEirCode();
		Map<String, String> countyInfo = getCountyData(zipCode);
		return countyInfo.get("city").toString();
	}

	public String zipCode() {
		String eir_code = getEirCode();
		String eir_code_part = faker.bothify("???#", true);
		return String.format("%s %s", eir_code, eir_code_part);
	}

	public String phoneNumber() {
		String phoneNumExp = "";
		try {
			phoneNumExp = faker.evalJsonPath("phoneNumber").getAsString();
		} catch (PathNotFoundException e) {
		}

		return faker.regexify(phoneNumExp).toUpperCase();
	}

	public String iban() {
		String countryCode = faker.getLoale().getCountryCode();

		String basicBankAccountNumber = faker.regexify("BOFI900017(\\d){8}");
		String checkSum = calculateIbanChecksum(countryCode, basicBankAccountNumber);
		return countryCode + checkSum + basicBankAccountNumber;
	}

	private String getEirCode() {
		String eirCodeExp = "";
		try {
			eirCodeExp = faker.evalJsonPath("eir_code").getAsString();
		} catch (PathNotFoundException e) {
		}
		return faker.regexify(eirCodeExp).toUpperCase();
	}

	private static String calculateIbanChecksum(String countryCode, String basicBankAccountNumber) {
		String basis = basicBankAccountNumber + countryCode + "00";

		StringBuilder sb = new StringBuilder();
		char[] characters = basis.toLowerCase().toCharArray();
		for (char c : characters) {
			if (Character.isLetter(c)) {
				sb.append(String.valueOf((c - 'a') + 10));
			} else {
				sb.append(c);
			}
		}

		int mod97 = new BigInteger(sb.toString()).mod(BigInteger.valueOf(97L)).intValue();
		return StringUtils.leftPad(String.valueOf(98 - mod97), 2, '0');
	}

	private Map<String, String> getCountyData(String zipCode) {
		String filterPredicate = "eir_map." + zipCode.trim();
		JsonObject filteredJson = faker.evalJsonPath("{\"city\":\"\",\"county\":\"\"}", "").getAsJsonObject();

		try {
			filteredJson = faker.evalJsonPath(filterPredicate).getAsJsonArray().get(0).getAsJsonObject();
		} catch (PathNotFoundException e) {
		}
		return new Gson().fromJson(filteredJson, Map.class);
	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.faker.extender;

import com.boi.grp.utilities.faker.enums.FakerLocale;
import com.github.javafaker.Faker;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.jayway.jsonpath.Configuration;
import com.jayway.jsonpath.JsonPath;
import com.jayway.jsonpath.Option;
import com.jayway.jsonpath.ParseContext;
import com.jayway.jsonpath.spi.json.GsonJsonProvider;

/*
**
* @author A113845
*
*/

public class FakerExtension extends Faker {
	private final FakerLocale fakerLocale;
	private final FakerDataExtension dataExtenstion;
	private String extensionMappingJson;
	private ParseContext parseContext;

	public FakerExtension() {
		this(FakerLocale.getDefault());
	}

	public FakerExtension(FakerLocale language) {
		super(language.getLocale());
		fakerLocale = language;
		Configuration conf = Configuration.builder().jsonProvider(new GsonJsonProvider())
				.options(Option.ALWAYS_RETURN_LIST, Option.SUPPRESS_EXCEPTIONS).build();
		parseContext = JsonPath.using(conf);
		extensionMappingJson = ((JsonArray) parseContext
				.parse(getClass().getClassLoader().getResourceAsStream("faker_config/config.json"))
				.read("$." + fakerLocale.toString())).get(0).toString();
		dataExtenstion = new FakerDataExtension(this);
	}

	public FakerLocale getLoale() {
		return fakerLocale;
	}

	public FakerDataExtension dataExtenstion() {
		return dataExtenstion;
	}

	public JsonElement evalJsonPath(String jsonPath) {
		return evalJsonPath(extensionMappingJson, jsonPath);
	}

	public JsonElement evalJsonPath(String json, String jsonPath) {
		return ((JsonArray) parseContext.parse(json).read(jsonPath.length() > 0 ? "$." + jsonPath : "$")).get(0);
	}
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

package com.boi.grp.utilities.faker;

import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.Random;

import com.boi.grp.utilities.faker.enums.FakerField;
import com.boi.grp.utilities.faker.enums.FakerFieldType;
import com.boi.grp.utilities.faker.enums.FakerLocale;
import com.boi.grp.utilities.faker.extender.FakerExtension;
import com.github.javafaker.service.FakeValuesService;
import com.github.javafaker.service.RandomService;

/**
 * @author A113845
 * 
 *         This is the primary class to generate random data using JavaFaker
 *
 */
public class DataGenerator {
	FakerLocale dataLanguage;
	FakeValuesService service;
	FakerExtension generator;

	public DataGenerator() {
		this(FakerLocale.getDefault());
	}

	public DataGenerator(FakerLocale language) {
		dataLanguage = language;
		service = new FakeValuesService(new Locale(dataLanguage.toString()), new RandomService());
		generator = new FakerExtension(language);
	}

	/**
	 * To generate fake data for a specific FakerField.
	 * 
	 * @param field - This is an onject of Fakerfield enum
	 * @return It will return the data for the field passed to the method
	 */
	public Object getData(FakerField field) {
		Object data = null;
		try {
			FakerFieldType tmpField = field.getParent();
			Object genFaker = new FakerExtension();
			Class<?> reflectionClass = FakerExtension.class;
			List<FakerFieldType> fieldStack = new ArrayList<FakerFieldType>();
			fieldStack.add(0, tmpField);
			while (!tmpField.isRootNode()) {
				fieldStack.add(0, tmpField.getParent());
				tmpField = tmpField.getParent();
			}

			for (FakerFieldType fakerField : fieldStack) {
				Method generatorMethod = reflectionClass.getMethod(fakerField.getMethodName());
				reflectionClass = fakerField.getFakerClass();
				genFaker = fakerField.getFakerClass().cast(generatorMethod.invoke(genFaker));
			}
			Method generatorMethod = reflectionClass.getMethod(field.getMethodName());
			data = generatorMethod.invoke(genFaker);
		} catch (Exception e) {
			// e.printStackTrace();
			System.err.println(field.toString());
		}
		return data;
	}

	/**
	 * To generate a CSV of fake data for a specific FakerField list.
	 * 
	 * 
	 * @param fieldList   - List of fields for which data has to be generated
	 * @param recordCount - Number of dataset to be generated
	 * @throws IOException
	 */
	public void getData(List<FakerField> fieldList, int recordCount) {
		getData(fieldList, recordCount, System.getProperty("user.dir") + "/generatedData.csv");
	}

	public void getData(String[] fieldNames, int recordCount, String resultFilePath) {
		getData(FakerField.getFields(fieldNames), recordCount, resultFilePath);
	}

	public void getData(String[] fieldNames, int recordCount) {
		getData(FakerField.getFields(fieldNames), recordCount);
	}

	/**
	 * To generate a CSV of fake data for a specific FakerField list.
	 * 
	 * 
	 * @param fieldList      - List of fields for which data has to be generated
	 * @param recordCount    - Number of dataset to be generated
	 * @param resultFilePath - Number of dataset to be generated
	 * @throws IOException
	 */
	public void getData(List<FakerField> fieldList, int recordCount, String resultFilePath) {
		try {
			FileWriter writer = new FileWriter(resultFilePath);
			for (FakerField fakerField : fieldList) {
				writer.append(fakerField.toString() + ",");
			}
			for (int counter = 0; counter < recordCount; counter++) {
				writer.append(System.getProperty("line.separator"));
				for (FakerField fakerField : fieldList) {
					writer.append(getData(fakerField) + ",");
				}
			}
			writer.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * To generate data based on a regular expression
	 * 
	 * @param expressString - Regular expression to generate data
	 * @return A fake data matching the regular expression
	 */
	public String resolveExpression(String expressString) {
		return service.regexify(expressString);
	}

	/**
	 * To generate a random word of specific length
	 * 
	 * @param wordSize - Length of word
	 * @return - A String of specified length
	 */
	public String getRandomWord(int wordSize) {
		String expression = String.join("", Collections.nCopies(wordSize, "?"));
		return shuffle(service.letterify(expression));
	}

	/**
	 * To generate a random number of specific length
	 * 
	 * @param numberLength - size of number
	 * @return - A string of numbers of specified length
	 */
	public String getRandomNumber(int numberLength) {
		String expression = String.join("", Collections.nCopies(numberLength, "#"));
		return service.numerify(expression);
	}

	/**
	 * To generate a random alphanumeric word of specific length
	 * 
	 * @param size - size of word
	 * @return - A string of \specified length
	 */
	public String getAlphaNumeric(int size) {
		Random rnd = new Random();
		int alphaSize = rnd.nextInt(size / 2);
		int numSize = size - alphaSize;
		return shuffle(getAlphaNumeric(alphaSize, numSize));
	}

	/**
	 * To generate a random alphanumeric word of specific length
	 * 
	 * @param alphaSize - Number of alphabets to be included
	 * @param numSize   - Number of digits to include
	 * @return - An alphanumeric string with specified number of alphabets and
	 *         digits
	 */
	public String getAlphaNumeric(int alphaSize, int numSize) {
		String aplhaString = getRandomWord(alphaSize);
		String numString = getRandomNumber(numSize);
		return shuffle(aplhaString + numString);
	}

	// public String getRandomEmailAddress() {
	// Random rnd = new Random();
	// String emailId = getRandomWord(rnd.ints(1, 8).findFirst().getAsInt()) +
	// "."
	// + getRandomWord(rnd.ints(1, 9).findFirst().getAsInt());
	// String domain = getRandomWord(rnd.ints(2, 6).findFirst().getAsInt()) +
	// "." + getRandomWord(3);
	// return String.format("%s@%s", emailId, domain);
	// }

	// public String getRandomEmailAddress(int emailIdLength) {
	// Random rnd = new Random();
	// int idPart1Length = rnd.ints(1, emailIdLength /
	// 2).findFirst().getAsInt();
	// int idPart2Length = emailIdLength - idPart1Length - 1;
	// String emailId = getRandomWord(idPart1Length) + "." +
	// getRandomWord(idPart2Length);
	// String domain = getRandomWord(rnd.ints(2, 6).findFirst().getAsInt()) +
	// "." + getRandomWord(3);
	// return String.format("%s@%s", emailId, domain);
	// }

	/**
	 * To shuffle a string
	 * 
	 * @param raw - Actual string
	 * @return - A shuffled String
	 */
	private String shuffle(String raw) {
		List<Character> charList = new ArrayList<Character>();
		for (char c : raw.toCharArray()) {
			charList.add(c);
		}
		StringBuilder output = new StringBuilder(raw.length());
		while (charList.size() != 0) {
			int randPicker = (int) (Math.random() * charList.size());
			output.append(charList.remove(randPicker));
		}
		return output.toString();
	}
}


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

